
\begin{Interfaz}
  \textbf{se explica con}: \tadNombre{Campus Seguro}.

  \textbf{géneros}: \TipoVariable{campusSeg}.

  \tituloModulo{Operaciones básicas de campusSeg}

  \InterfazFuncion{Vacía}{}{lista$(\alpha)$}%
  {$res \igobs \secuencia{}$}%
  [$\Theta(1)$]
  [genera una lista vacía.]

  \InterfazFuncion{AgregarAdelante}{\Inout{l}{lista($\alpha$)}, \In{a}{$\alpha$}}{itLista($\alpha$}
  [$l \igobs l_0$]
  {$l \igobs \secuencia{a}[l_0]$ $\land$ $res$ $=$ CrearItBi(\secuencia{}, $l$) $\land$ alias(SecuSuby($res$) $=$ $l$)}
  [$\Theta(copy(a))$]
  [agrega el elemento $a$ como primer elemento de la lista.  Retorna un iterador a $l$, de forma tal que Siguiente devuelva $a$.]
  [el elemento $a$ agrega por copia. El iterador se invalida si y sólo si se elimina el elemento siguiente del iterador sin utilizar la función \NombreFuncion{EliminarSiguiente}.]


\end{Interfaz}

\begin{Representacion}
  
  \tituloModulo{Representación de campusSeg}

  \begin{Estructura}{campusSeg}[estr]
    \begin{Tupla}[estr]
		\tupItem{hippies}{diccNombres(nombre,posicion)}%
		\tupItem{estudiantes}{diccNombres(nombre,posicion)\\}
		\tupItem{agentes}{diccAg(placa,datosAg)}
		\tupItem{sanciones}{diccSanc(nat,conj(placa))}\\
		\tupItem{placasPos}{diccLog(placa,posicion)}\\
		\tupItem{pos}{posiciones}
		\tupItem{masVigilante}{datosAg}
		\tupItem{cp}{campus}
    \end{Tupla}
    
	\begin{Tupla}[posiciones]
		\tupItem{mAg}{matriz(tupla(bool,datosAg)}\\
		\tupItem{mH}{matriz(tupla(bool,itdicc(nombre, posicion))}\\
		\tupItem{mE}{matriz(tupla(bool,itdicc(nombre, posicion))}
	\end{Tupla}
	
    \begin{Tupla}[datosAg]
      \tupItem{pl}{placa}
      \tupItem{sanciones}{nat}
      \tupItem{premios}{nat}
      \tupItem{pos}{posicion}%
      \tupItem{kSanc}{itdicc(nat, conj(placa)}%
      \tupItem{mismasSanc}{itconj(placa)}%
    \end{Tupla}
  \end{Estructura}

  \tituloModulo{Aclaraciones}
	Dada la complejidad de la estructura, el invariante puede ser dificil de seguir, por lo que a continuacion se encuentra detallado de manera informal las lineas que se siguieron al hacer el rep.
	
	\begin{enumerate}
		\item Las claves de hippies y estudiantes intersecan vacio.
		\item No hay posiciones iguales en estudiantes, hippies y placasPos y todas se encuentran en rango.
		\item Las placas de agentes y placasPos son iguales y igual placa, misma posicion.
		\item Las claves de sanciones y las diferentes sanciones de agentes forman el mismo conjunto. Los conjuntos de placas de la clave i de sanciones tienen todas las placas cuyos agentes tengan i sanciones.
		\item Para todos los datosAg de agentes, la secuencia subyacente del iterador kSanc es igual a una secuencia ordenada de sanciones y la siguiente clave del iterador es la cantidad de sanciones del datosAg.
		\item Para todos los datosAg de agentes, la secuencia subyacente del iterador mismasSanc es permutacion del conjunto de placas del diccionario sanciones donde se encuentra su propia placa, y el siguiente del iterador es su misma placa.
		\item filas+1 y columnas+1 de cp (campus) es igual al alto y ancho de las matrices de pos.
		\item mAg, el booleano es true si y solo si hay un agente en placasPos en esa posicion.\\
		Si es true, los datosAg son iguales para esa placa.
		\item mH, el booleano es true si y solo si hay un hippie en esa posicion.\\
		Si es true,la siguiente clave del iterador es el hippie en esa posicion y la secuencia subyacente es permutacion de los hippies en hippies.
		\item mE, el booleano es true si y solo si hay un estudiante en esa posicion.\\
		Si es true,la siguiente clave del iterador es el estudiante en esa posicion y la secuencia subyacente es permutacion de los estudiantes en estudiantes.
		\item El mas vigilante es el de mayor sanciones de los agentes y, entre ellos, el de menor placa.
	\end{enumerate}
	
	Para facilitar la lectura se renombra las matrices $e$.pos.mXX a mXX
  \Rep[estr]{
	\begin{enumerate}
		\item claves($e$.hippies) $\cap$ claves(e.estudiantes) = $\emptyset$
		\item $\land$ ($\forall p$: posicion)($\#$($p$,armarMultiPos($e$)) $\geq$ 1 $\implies$ \\
		$\#$($p$,armarMultiPos($e$)) = 1 $\land$ posValida($p$,$e$.cp) $\yluego$ $\neg$ocupada?($p$,$e$.cp))
		\item $\land$ (claves($e$.agentes) $=$ claves($e$.placasPos) $\yluego$ ($\forall p$: placa) (def?($p$,e.placasPos) $\impluego$ \\
		obtener($p$,$e$.placasPos) = obtener($p$,$e$.agentes).pos))
		\item $\land$ unionSignificados($e$.sanciones) = claves($e$.agentes)\\
		$\land$ ($\forall n$: nat) def?($n$,$e$.sanciones) $\impluego$ \\
		($\neg$(obtener($n$,$e$.sanciones) = $\emptyset$) $\land$ ($\forall p$: placa) ($p \in$ obtener($n$,$e$.sanciones) $\implies$ \\
		def?($p$,$e$.agentes) $\yluego$ (obtener($p$,$e$.agentes).pl = p $\land$ obtener($p$,$e$.agentes).sanciones = n))
		\item $\land$ ($\forall p$: placa) def?($p$,$e$.agentes) $\impluego$ \\
		SecuSuby(obtener($p$,$e$.agentes).kSanc) = ordenar$\pi_1$(secuenciarDic($e$.sanciones)) \\
		$\land$ $pi_1$(Siguiente(obtener($p$,$e$.agentes).kSanc)) = obtener($p$,$e$.agentes).pl
		\item $\land$ ($\forall p$: placa) (def?($p$,$e$.agentes) $\yluego$ def?(obtener($p$,$e$.agentes).sanciones,$e$.sanciones) $\impluego$ \\
		esPermutacion(SecuSuby(obtener($p$,$e$.agentes).mismasSanc),\\
		secuenciarConj(obtener(obtener($p$,$e$.agentes).sanciones,$e$.sanciones)))\\
		$\land$ siguiente(obtener($p$,$e$.agentes).mismasSanc) = $p$
		\item $\land$ Ancho(mAg) = columnas($e$.campus) + 1 $\land$ Alto(mAg) = filas($e$.campus) + 1 \\
		$\land$ Ancho(mH) = Ancho(mAg) $\land$ Alto(mH) = Alto(mAg)\\
		$\land$ Ancho(mE) = Ancho(mH) $\land$ Alto(mE) = Alto(mH)
		\item $\land$ ($\forall i$: nat) ($\forall j$: nat) 0 $< i <$ Ancho(mAg) $\land$ 0 $< j <$ Alto(mAg) $\impluego$ \\
		($pi_1$(Valor(mAg,$i$,$j$)) $\iff$ \\
		($\exists n$: nombre)(def?($p$,$e$.placasPos) $\land$ def?($p$,$e$.agentes)) $\yluego$\\
		(obtener($p$,$e$.placasPos) = $\langle i$, $j \rangle$ $\land$ $\pi_2$(Valor(mAg,$i$,$j$)) = obtener($p$,$e$.agentes)))
		\item $\land$ ($\forall i$: nat) ($\forall j$: nat) 0 $< i <$ Ancho(mH) $\land$ 0 $< j <$ Alto(mH) $\impluego$ \\
		($\pi_1$(Valor(mH,$i$,$j$)) $\iff$ ($\exists n$: nombre)(def?($n$,$e$.hippies) $\yluego$ \\
		obtener($n$,$e$.hippies) = $\langle i$, $j \rangle$ $\land$ $\pi_1$(Siguiente($\pi_2$(Valor(mH,$i$,$j$)))) = $n$ $\land$ \\
		esPermutacion(SecuSuby($\pi_2$(Valor(mH,$i$,$j$)),secuenciarDic($e$.hippies)))
		\item $\land$ ($\forall i$: nat) ($\forall j$: nat) 0 $< i <$ Ancho(mE) $\land$ 0 $< j <$ Alto(mE) $\impluego$ \\
		($\pi_1$(Valor(mE,$i$,$j$)) $\iff$ ($\exists n$: nombre)(def?($n$,$e$.estudiantes) $\yluego$ \\
		obtener($n$,$e$.estudiantes) = $\langle i$, $j \rangle$ $\land$ $\pi_1$(Siguiente($\pi_2$(Valor(mE,$i$,$j$)))) = $n$ $\land$ \\
		esPermutacion(SecuSuby($\pi_2$(Valor(mE,$i$,$j$)),secuenciarDic($e$.estudiantes)))
		\item $\#$claves($e$.agentes) $\geq$ 1 $\implies$ ($\exists p$: placa) def?($p$,$e$.agentes) $\yluego$ \\
		(obtener($p$,$e$.agentes) = $e$.masVigilante $\land$ \\
		(($\forall p':$ placa) def?($p'$,$e$.agentes) $\land p \neq p' \impluego$\\
		(obtener($p$,$e$.agentes).premios $\geq$ obtener($p'$.$e$.agentes).premios $\land$ \\
		(obtener($p$,$e$.agentes).premios = obtener($p'$,$e$.agentes) $\implies$ $p < p'$))))

	\end{enumerate}
  }\mbox{}
	
	\clearpage

	\tadOperacion{armarMultiPos}{estr}{multiconj(posicion)}{}
	\tadAxioma{armarMultiPos($e$)}{multiSignificados($e$.placasPos,claves($e$.placasPos)) $\cup$ \\
	multiSignificados($e$.hippies,claves($e$.hippies)) $\cup$ \\
	multiSignificados($e$.estudiantes,claves($e$.estudiantes)}

  ~

  \tadOperacion{multiSignificados}{dicc($\beta$,$\alpha$)/d, conj($\beta$)/c}{multiconj($\alpha$)}{($\forall cl: \beta$) $cl \in c \implies$ def?(cl,d)}
  \tadAxioma{multiSignificados($d$,$c$)}{
  \IF $\emptyset$?($c$) THEN $\emptyset$ 
  ELSE Ag(obtener(dameUno($c$),$d$),multiSignificados($d$,sinUno($c$)))
  FI}

  ~

  \tadOperacion{unionSignificados}{dicc($\beta$,$\alpha$)/d}{conj($\alpha$)}{}
  \tadAxioma{unionSignificados($d$)}{multiAConj(multiSignificados($d$,claves($d$)))}

  ~

  \tadOperacion{multiAConj}{multiconj($\alpha$)}{conj($\alpha$)}{}
  \tadAxioma{multiAConj($mc$)}{\IF $mc$ = $\emptyset$ THEN $\emptyset$ 
  ELSE Ag(dameUno($mc$),multiAConj(sinUno($mc$)))
  FI}

  ~

  \tadOperacion{secuenciarDic}{dicc($\beta$,$\alpha$)}{secu($\langle \beta, alpha \rangle$)}{}
  \tadAxioma{secuenciarDic($d$)}{secuenciarDicAux($d$,claves($d$)}

  ~

  \tadOperacion{secuenciarDicAux}{dicc($\beta$,$\alpha$)/d, conj($\beta$)/c}{secu($\langle \beta, \alpha \rangle$)}{($\forall cl: \beta$) $cl \in c \implies$ def?(cl,d)}
  \tadAxioma{secuenciarDicAux($d$,$c$)}{
  \IF $\emptyset$?($c$) THEN $<>$ 
  ELSE $\langle$dameUno($c$),obtener(dameUno($c$),$d$)$\rangle$ $\bullet$ secuenciarDicAux($d$,sinUno($c$))
  FI}

  ~

  \tadOperacion{ordenar$\pi_1$}{secu($\langle \beta $,$ \alpha \rangle$)}{secu($\langle \beta, \alpha \rangle$)}{}
  \tadAxioma{ordenar$\pi_1$($s$)}{
  \IF vacia?($s$) THEN $<>$ 
  ELSE min$\pi_1$($s$) $\bullet$ ordenar$\pi_1$(fin($s$))
  FI}

  ~

  \tadOperacion{min$\pi_1$}{secu($\langle \beta $,$ \alpha \rangle$)/s}{$\langle \beta, \alpha \rangle$}{$\neg$vacia?($s$)}
  \tadAxioma{min$\pi_1$($s$)}{minAux$\pi_1$($s$,prim($s$)}

  ~
  
  \tadOperacion{minAux$\pi_1$}{secu($\langle \beta $,$ \alpha \rangle$)/s, $\langle \beta $ , $\alpha \rangle$}{$\langle \beta, \alpha \rangle$}{$\neg$vacia?($s$)}
  \tadAxioma{minAux$\pi_1$($s$,$e$}{\IF long($s$) = 1 THEN 
  {\IF $\pi_1$(prim($s$)) < $\pi_1$($e$) THEN prim($s$) ELSE $e$ FI} 
  ELSE minAux$\pi_1$(fin($s$),
  {\IF $\pi_1$(prim($s$)) < $\pi_1$($e$) THEN prim($s$) ELSE $e$ FI}
  FI}

  ~
  
  \AbsFc[estr]{campusSeg}[e]
  {$cs$: campusSeg $/$ e.cp = campus(cs) $\land$ claves($e$.estudiantes) = estudiantes($cs$) \\ $\land$ claves($e$.hippies) = hippies($cs$) $\land$ claves($e$.agentes) = agentes(cs) $\land$ \\
  ($\forall a$: agente)(($a \in$ agentes($cs$) $\iff$ def?($a$,$e$.agentes)) $\yluego$ ($a \in$ agentes($cs$) $\impluego$ \\
  (obtener($a$,$e$.agentes).sanciones = cantSanciones($a$,$cs$) $\land$\\
  obtener($a$,$e$.agentes).premios = cantHippiesAtrapados($a$,$cs$) $\land$\\
  obtener($a$,$e$.agentes).posicion = posAgente($a$,$cs$)))) $\yluego$ \\
  ($\forall n:$ nombre)(def?($n$,$e$.hippies) $\impluego$ posEstudianteYHippie($n$,$cs$) = obtener($a$,$e$.hippies)) $\land$\\
  (def?($n$,$e$.estudiantes) $\impluego$ posEstudianteYHippie($n$,$cs$) = obtener($a$,$e$.estudiantes)) }


\begin{Algoritmos}



\end{Algoritmos}

\end{Representacion}

