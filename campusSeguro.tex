
Se sigue el siguiente orden para las funciones que proveen los movimientos de estudiantes, agentes o hippies.
\begin{enumerate}
	\item Apariciones y Movimientos
	\item Enhippizacion (Estudiantes en hippies)
	\item Educacion (Hippies en estudiantes)
	\item Premios de capturas de hippies
	\item Captura de hippies
	\item Sanciones relacionadas con el evento
\end{enumerate}

\begin{Interfaz}

	\textbf{se explica con}: \tadNombre{Campus Seguro}.

	\textbf{géneros}: \TipoVariable{campusSeg}.

	\tituloModulo{Operaciones básicas de campusSeg}

	\InterfazFuncion{Campus}{\In{c}{campusSeg}}{campus}
	{$res \igobs $campus($c$)}
	[$\Ogr(1)$]
	[Devuelve el campus de Campus Seguro]
	[El campus se devuelve por referencia]

	\InterfazFuncion{Estudiantes}{\In{c}{campusSeg}}{itClavesDiccN(nombre,posicion)}
	{esPermutacion(Siguientes($res$),secuenciarConj(estudiantes($d$))}
	[$\Ogr(1)$]
	[Devuelve Iterador no modificable de todos los estudiantes actualmente en el campus]
	[Si hay un cambio en los estudiantes, el iterador puede quedar invalidado]
  
	\InterfazFuncion{Hippies}{\In{c}{campusSeg}}{itClavesDiccN(nombre,posicion)}
	{esPermutacion(Siguientes($res$),secuenciarConj(hippies($d$))}
	[$\Ogr(1)$]
	[Devuelve Iterador no modificable de todos los hippies actualmente en el campus]
	[Si hay un cambio en los hippies, el iterador puede quedar invalidado]

	\InterfazFuncion{Agentes}{\In{c}{campusSeg}}{itClavesDiccLog(nat)}
	{esPermutacion(Siguientes($res$),secuenciarConj(agentes($c$)))}
	[$\Ogr(1)$]
	[Devuelve Iterador no modificable de todos los agentes actualmente en el campus]
	[Si hay un cambio en el diccionario, se va a ver reflejado en el iterador]

	\InterfazFuncion{PosEstudianteYHippie}{\In{c}{campusSeg}, \In{n}{nombre}}{posicion}
	[$n \in$ estudiantes($c$)$\cup$hippies($c$)]
	{$res \igobs$posEstudianteYHippie($n$,$c$)}
	[$\Ogr(|n_m|)$ con siendo $|n_m|$ la longitud del nombre más largo de hippies y estudiantes]
	[Devuelve la posicion del estudiante o hippie]

	\InterfazFuncion{PosAgente}{\In{c}{campusSeg}, \In{p}{placa}}{posicion}
	[$pl \in$ agentes($c$)]
	{$res \igobs$ posAgente($pl$,$c$)}
	[$\Ogr(1)$ en caso promedio]
	[Devuelve la posicion del agente]

	\InterfazFuncion{CantSanciones}{\In{c}{campusSeg}, \In{pl}{placa}}{nat}
	[$pl \in$ agentes($c$)]
	{$res \igobs$ cantSanciones($pl$,$c$)}
	[$\Ogr(1)$ en caso promedio]
	[Devuelve la cantidad de sanciones del agente]
	
	\InterfazFuncion{CantHippiesAtrapados}{\In{c}{campusSeg}, \In{pl}{placa}}{nat}
	[$pl \in$ agentes($c$)]
	{$res \igobs$ cantHippiesAtrapados($pl$,$c$)}
	[$\Ogr(1)$ en caso promedio]
	[Devuelve la cantidad de hippies que atrapo el agente]

	\InterfazFuncion{ComenzarRastrillaje}{\In{c}{campus}, \In{d}{dicc(agente,posicion)}}{campusSeg}%
	[($\forall a$: agente)def?($a$,$d$)$\impluego$ posValida?(obtener($a$,$d$))$\land \neg$ocupada?(obtener($a$,$d$),$c$)))\\
  $\land$($\forall a_0,a_1$: agente)((def?($a_0$,$d$)$\land$def?($a_1$,$d$)$\land a_0 \neq a_1$)$\impluego$obtener($a_0$,$d$)$\neq$obtener($a_1$,$d$))]
	{$res \igobs $comenzarRastrillaje($c$,$d$)}%
	[$\Ogr$($h*a + n^2$) + $\Ogr(n)$ prom]
	[Inicializa toda la estructura en funcion de los datos de entrada]

	\InterfazFuncion{IngresarEstudiante}{\Inout{c}{campusSeg}, \In{n}{nombre}, \In{p}{posicion}}{}
	[$c$ = $c_0 \land n \notin$ (estudiantes($c$)$\cup$hippies($c$))$\land$esIngreso($p$,campus($c$))$\land \neg$ estaOcupada?($p$,$c$)]
	{$c$ = ingresarEstudiante($n$,$p$,$c_0$)}
	[$\Ogr(|n_m|)$]
	
	\InterfazFuncion{IngresarHippie}{\Inout{c}{campusSeg}, \In{n}{nombre}, \In{p}{posicion}}{}
	[$c$ = $c_0 \land n \notin$  (estudiantes($c$)$\cup$hippies($c$))$\land$esIngreso($p$,campus($c$))$\land \neg$ estaOcupada?($p$,$c$)]
	{$c$ = ingresarHippie($n$,$p$,$c_0$)}
	[$\Ogr(|n_m|)$]
	
	\InterfazFuncion{MoverEstudiante}{\Inout{c}{campusSeg}, \In{n}{nombre}, \In{d}{direccion}}{}
	[$c$ = $c_0 \land n \in$ estudiantes($c$)$\land$(seRetira($n$,$d$,$c$)$\lor$\\(posValida(proxPosicion(posEstudianteYHippie($n$,$c$), $d$,campus($c$)),campus($c$))$\land$\\
	$\neg$estaOcupada?(proxPosicion(posEstudianteYHippie($n$,$c$),$d$,campus($c$)),$c$)))]
	{$c$ = moverEstudiante($n$,$d$,$c_0$)}
	[$\Ogr(|n_m|)$]
	
	\InterfazFuncion{MoverHippie}{\Inout{c}{campusSeg}, \In{n}{nombre}}{}
	[$c$ = $c_0 \land n \in$ hippies($c$)$\land \neg$todasOcupadas?(vecinos(posEstudianteYHippie($n$,$c$),campus($c$)),$c$)]
	{$c$ = moverHippie($n$,$c_0$)}
	[$\Ogr(|n_m|) + \Ogr(N_e)$]

	\InterfazFuncion{MoverAgente}{\Inout{c}{campusSeg}, \In{a}{agente}}{}
	[$c$ = $c_0 \land$\\
	$a \in$ agentes($c$)$\yluego$ cantSanciones($a$,$c$) $\leq$ 3 $\land$ $\neg$todasOcupadas?(vecinos(posAgente($a$,$c$),campus($c$)),$c$) ]
	{$c$ = moverAgente($a$,$c_0$)}
	[$\Ogr(|n_m|) + \Ogr(log N_a) + \Ogr(N_h)$]
	
	\InterfazFuncion{MasVigilante}{\In{c}{campusSeg}}{placa}
	[$\#Agentes(c) \geq$ 1]
	{$res \igobs$masVigilante($c$)}
	[$\Ogr(1)$]

	\InterfazFuncion{ConMismasSanciones}{\In{c}{campusSeg}, \In{a}{agente}}{conj(placa)}
	[$a \in Agentes(c)$]
	{$res \igobs$ conMismasSanciones($a$,$c$)}
	[$\Ogr(1)$]
	[El conjunto se devuelve por referencia y no se puede modificar]	
	
	\InterfazFuncion{ConKSanciones}{\In{c}{campusSeg}, \In{k}{nat}}{conj(placa)}
	{$res \igobs$ conKsanciones($k$,$c$)}
	[$\Ogr(1)$]
	[El conjunto se devuelve por referencia y no se puede modificar]
		
	\InterfazFuncion{CantHippies}{\In{c}{campusSeg}}{nat}
	{$res \igobs$ cantHippies($c$)}
	[$\Ogr(1)$]

	\InterfazFuncion{CantEstudiantes}{\In{c}{campusSeg}}{nat}
	{$res \igobs$ cantEstudiantes($c$)}
	[$\Ogr(1)$]	
	
\end{Interfaz}

\begin{Representacion}
  
  \tituloModulo{Representación de campusSeg}

  \begin{Estructura}{campusSeg}[estr]
    \begin{Tupla}[estr]
		\tupItem{hippies}{diccNombres(nombre,posicion)}%
		\tupItem{estudiantes}{diccNombres(nombre,posicion)}\\
		\tupItem{agentes}{diccLog(nat,datosAg)}\\
		\tupItem{sanciones}{diccSanc(nat,conj(placa))}\\
		\tupItem{agentesRapido}{diccH(nat,itDiccLog(nat,posicion))}\\
		\tupItem{pos}{posiciones}
		\tupItem{masVigilante}{tupla(pl: placa, premios: nat}
		\tupItem{cp}{campus}
    \end{Tupla}
    
	\begin{Tupla}[posiciones]
		\tupItem{mAg}{matriz(tupla(def: bool,datos: itDiccLog(nat,posicion))}\\
		\tupItem{mH}{matriz(tupla(def: bool,datos: itDiccN(nombre, posicion))}\\
		\tupItem{mE}{matriz(tupla(def: bool,datos: itDiccN(nombre, posicion))}
	\end{Tupla}
	
    \begin{Tupla}[datosAg]
      \tupItem{pl}{placa}
      \tupItem{sanciones}{nat}
      \tupItem{premios}{nat}
      \tupItem{pos}{posicion}%
      \tupItem{kSanc}{itDiccS(nat, conj(placa)}%
      \tupItem{mismasSanc}{itconj(placa)}%
    \end{Tupla}
  \end{Estructura}

  \tituloModulo{Aclaraciones}
	Dada la complejidad de la estructura, el invariante puede ser dificil de seguir, por lo que a continuacion se encuentra detallado de manera informal las lineas que se siguieron al hacer el rep.
	
	\begin{enumerate}
		\item Las claves de hippies y estudiantes intersecan vacio.
		\item No hay posiciones iguales en estudiantes, hippies y agentes y todas se encuentran en rango.
		\item Las placas de agentes y agentesRapido son iguales y, a igual placa, el siguiente del iterador de agentesRapido es el agente en agentes y la secuencia subyacente del iterador es permutacion de la secuencia de tuplas del diccionario de agentes.
		\item Las claves de sanciones y las diferentes sanciones de agentes forman el mismo conjunto. Los conjuntos de placas de la clave i de sanciones tienen todas las placas cuyos agentes tengan i sanciones.
		\item Para todos los datosAg de agentes, la secuencia subyacente del iterador kSanc es igual a una secuencia ordenada de sanciones y la siguiente clave del iterador es la cantidad de sanciones del datosAg.
		\item Para todos los datosAg de agentes, la secuencia subyacente del iterador mismasSanc es permutacion del conjunto de placas del diccionario sanciones donde se encuentra su propia placa, y el siguiente del iterador es su misma placa.
		\item filas+1 y columnas+1 de cp (campus) es igual al alto y ancho de las matrices de pos.
		\item mAg, el booleano es true si y solo si hay un agente en placasPos en esa posicion.\\
		Si es true, la siguiente clave del iterador es el agente en esa posicion y la secuencia subyacente es permutacion de los agentes en agentes.
		\item mH, el booleano es true si y solo si hay un hippie en esa posicion.\\
		Si es true, la siguiente clave del iterador es el hippie en esa posicion y la secuencia subyacente es permutacion de los hippies en hippies.
		\item mE, el booleano es true si y solo si hay un estudiante en esa posicion.\\
		Si es true,la siguiente clave del iterador es el estudiante en esa posicion y la secuencia subyacente es permutacion de los estudiantes en estudiantes.
		\item El mas vigilante es el de mayor sanciones de los agentes y, entre ellos, el de menor placa.
	\end{enumerate}
	
	Para facilitar la lectura se renombra las matrices $e$.pos.mXX a mXX
  \Rep[estr]{
	\begin{enumerate}
		\item claves($e$.hippies) $\cap$ claves(e.estudiantes) = $\emptyset$
		\item $\land$ ($\forall p$: posicion)($\#$($p$,armarMultiPos($e$)) $\geq$ 1 $\implies$ \\
		$\#$($p$,armarMultiPos($e$)) = 1 $\land$ posValida($p$,$e$.cp) $\yluego$ $\neg$ocupada?($p$,$e$.cp))
		\item $\land$ (claves($e$.agentes) $=$ claves($e$.agentesRapido) $\yluego$ ($\forall p$: placa) (def?($p$,e.agentes) $\impluego$ \\
		$\pi_1$(Siguiente(obtener($p$,$e$.agentesRapido))) = obtener($p$,$e$.agentes))\\
		$\land$ esPermutacion(SecuSuby(obtener($p$,$e$.agentesRapido)),secuenciarDic($e$.agentes)))
		\item $\land$ unionSignificados($e$.sanciones) = claves($e$.agentes)\\
		$\land$ ($\forall n$: nat) def?($n$,$e$.sanciones) $\impluego$ \\
		($\neg$(obtener($n$,$e$.sanciones) = $\emptyset$) $\land$ ($\forall p$: placa) ($p \in$ obtener($n$,$e$.sanciones) $\implies$ \\
		def?($p$,$e$.agentes) $\yluego$ (obtener($p$,$e$.agentes).pl = p $\land$ obtener($p$,$e$.agentes).sanciones = n))
		\item $\land$ ($\forall p$: placa) def?($p$,$e$.agentes) $\impluego$ \\
		SecuSuby(obtener($p$,$e$.agentes).kSanc) = ordenar$\pi_1$(secuenciarDic($e$.sanciones)) \\
		$\land$ $pi_1$(Siguiente(obtener($p$,$e$.agentes).kSanc)) = obtener($p$,$e$.agentes).pl
		\item $\land$ ($\forall p$: placa) (def?($p$,$e$.agentes) $\yluego$ def?(obtener($p$,$e$.agentes).sanciones,$e$.sanciones) $\impluego$ \\
		esPermutacion(SecuSuby(obtener($p$,$e$.agentes).mismasSanc),\\
		secuenciarConj(obtener(obtener($p$,$e$.agentes).sanciones,$e$.sanciones)))\\
		$\land$ siguiente(obtener($p$,$e$.agentes).mismasSanc) = $p$
		\item $\land$ Ancho(mAg) = columnas($e$.campus) + 1 $\land$ Alto(mAg) = filas($e$.campus) + 1 \\
		$\land$ Ancho(mH) = Ancho(mAg) $\land$ Alto(mH) = Alto(mAg)\\
		$\land$ Ancho(mE) = Ancho(mH) $\land$ Alto(mE) = Alto(mH)
		\item $\land$ ($\forall i$: nat) ($\forall j$: nat) 0 $< i <$ Ancho(mAg) $\land$ 0 $< j <$ Alto(mAg) $\impluego$ \\
		($pi_1$(Valor(mAg,$i$,$j$)) $\iff$ \\
		($\exists p$: placa) def?($p$,$e$.agentes) $\yluego$ (obtener($p$,$e$.agentes).pos = $\langle i$, $j \rangle$ $\land$ \\ 
		esPermutacion(SecuSuby($\pi_2$(Valor(mAg,$i$,$j$))), secuenciarDic(agentes)) \\
		$\land$ $\pi_1$(Siguiente($\pi_2$(Valor(mAg,$i$,$j$))) = obtener($p$,$e$.agentes).pl)
		\item $\land$ ($\forall i$: nat) ($\forall j$: nat) 0 $< i <$ Ancho(mH) $\land$ 0 $< j <$ Alto(mH) $\impluego$ \\
		($\pi_1$(Valor(mH,$i$,$j$)) $\iff$ ($\exists n$: nombre)(def?($n$,$e$.hippies) $\yluego$ \\
		obtener($n$,$e$.hippies) = $\langle i$, $j \rangle$ $\land$ $\pi_1$(Siguiente($\pi_2$(Valor(mH,$i$,$j$)))) = $n$ $\land$ \\
		esPermutacion(SecuSuby($\pi_2$(Valor(mH,$i$,$j$)),secuenciarDic($e$.hippies)))
		\item $\land$ ($\forall i$: nat) ($\forall j$: nat) 0 $< i <$ Ancho(mE) $\land$ 0 $< j <$ Alto(mE) $\impluego$ \\
		($\pi_1$(Valor(mE,$i$,$j$)) $\iff$ ($\exists n$: nombre)(def?($n$,$e$.estudiantes) $\yluego$ \\
		obtener($n$,$e$.estudiantes) = $\langle i$, $j \rangle$ $\land$ $\pi_1$(Siguiente($\pi_2$(Valor(mE,$i$,$j$)))) = $n$ $\land$ \\
		esPermutacion(SecuSuby($\pi_2$(Valor(mE,$i$,$j$)),secuenciarDic($e$.estudiantes)))
		\item $\#$claves($e$.agentes) $\geq$ 1 $\implies$ ($\exists p$: placa) def?($p$,$e$.agentes) $\yluego$ \\
		(obtener($p$,$e$.agentes).pl = $e$.masVigilante.pl $\land$ \\
		obtener($p$,$e$.agentes).premios = $e$.masVigilante.premios $\land$ \\
		(($\forall p':$ placa) def?($p'$,$e$.agentes) $\land p \neq p' \impluego$\\
		(obtener($p$,$e$.agentes).premios $\geq$ obtener($p'$.$e$.agentes).premios $\land$ \\
		(obtener($p$,$e$.agentes).premios = obtener($p'$,$e$.agentes) $\implies$ $p < p'$))))

	\end{enumerate}
  }\mbox{}
	
	\clearpage

	\tadOperacion{armarMultiPos}{estr}{multiconj(posicion)}{}
	\tadAxioma{armarMultiPos($e$)}{multiSignificados(soloPosAgentes($e$.agentes,claves($e$.agentes)),claves($e$.placasPos)) $\cup$ \\
	multiSignificados($e$.hippies,claves($e$.hippies)) $\cup$ \\
	multiSignificados($e$.estudiantes,claves($e$.estudiantes)}

  
  ~


  \tadOperacion{soloPosAgentes}{dicc(nat,datosAg)/d, conj($\beta$)/c}{dicc(nat,posicion)}{$c \subseteq claves(d)$}
  \tadAxioma{soloPosAgentes($d$,$c$)}{
  \IF $\emptyset$?($c$) THEN Vacio() 
  ELSE definir(dameUno($c$), obtener(dameUno($c$),$d$).pos,soloPosAgentes($d$,sinUno($c$)))
  FI}

  ~
  
  
  \tadOperacion{multiSignificados}{dicc($\beta$,$\alpha$)/d, conj($\beta$)/c}{multiconj($\alpha$)}{($\forall cl: \beta$) $cl \in c \implies$ def?(cl,d)}
  \tadAxioma{multiSignificados($d$,$c$)}{
  \IF $\emptyset$?($c$) THEN $\emptyset$ 
  ELSE Ag(obtener(dameUno($c$),$d$),multiSignificados($d$,sinUno($c$)))
  FI}

  ~

  \tadOperacion{unionSignificados}{dicc($\beta$,$\alpha$)/d}{conj($\alpha$)}{}
  \tadAxioma{unionSignificados($d$)}{multiAConj(multiSignificados($d$,claves($d$)))}

  ~

  \tadOperacion{multiAConj}{multiconj($\alpha$)}{conj($\alpha$)}{}
  \tadAxioma{multiAConj($mc$)}{\IF $mc$ = $\emptyset$ THEN $\emptyset$ 
  ELSE Ag(dameUno($mc$),multiAConj(sinUno($mc$)))
  FI}

  ~

  \tadOperacion{secuenciarDic}{dicc($\beta$,$\alpha$)}{secu($\langle \beta, alpha \rangle$)}{}
  \tadAxioma{secuenciarDic($d$)}{secuenciarDicAux($d$,claves($d$)}

  ~

  \tadOperacion{secuenciarDicAux}{dicc($\beta$,$\alpha$)/d, conj($\beta$)/c}{secu($\langle \beta, \alpha \rangle$)}{($\forall cl: \beta$) $cl \in c \implies$ def?(cl,d)}
  \tadAxioma{secuenciarDicAux($d$,$c$)}{
  \IF $\emptyset$?($c$) THEN $<>$ 
  ELSE $\langle$dameUno($c$),obtener(dameUno($c$),$d$)$\rangle$ $\bullet$ secuenciarDicAux($d$,sinUno($c$))
  FI}

  ~

  \tadOperacion{ordenar$\pi_1$}{secu($\langle \beta $,$ \alpha \rangle$)}{secu($\langle \beta, \alpha \rangle$)}{}
  \tadAxioma{ordenar$\pi_1$($s$)}{
  \IF vacia?($s$) THEN $<>$ 
  ELSE min$\pi_1$($s$) $\bullet$ ordenar$\pi_1$(fin($s$))
  FI}

  ~

  \tadOperacion{min$\pi_1$}{secu($\langle \beta $,$ \alpha \rangle$)/s}{$\langle \beta, \alpha \rangle$}{$\neg$vacia?($s$)}
  \tadAxioma{min$\pi_1$($s$)}{minAux$\pi_1$($s$,prim($s$)}

  ~
  
  \tadOperacion{minAux$\pi_1$}{secu($\langle \beta $,$ \alpha \rangle$)/s, $\langle \beta $ , $\alpha \rangle$}{$\langle \beta, \alpha \rangle$}{$\neg$vacia?($s$)}
  \tadAxioma{minAux$\pi_1$($s$,$e$}{\IF long($s$) = 1 THEN 
  {\IF $\pi_1$(prim($s$)) < $\pi_1$($e$) THEN prim($s$) ELSE $e$ FI} 
  ELSE minAux$\pi_1$(fin($s$),
  {\IF $\pi_1$(prim($s$)) < $\pi_1$($e$) THEN prim($s$) ELSE $e$ FI}
  FI}

  ~
  
  \AbsFc[estr]{campusSeg}[e]
  {$cs$: campusSeg $/$ e.cp = campus(cs) $\land$ claves($e$.estudiantes) = estudiantes($cs$) \\ $\land$ claves($e$.hippies) = hippies($cs$) $\land$ claves($e$.agentes) = agentes(cs) $\land$ \\
  ($\forall a$: agente)(($a \in$ agentes($cs$) $\iff$ def?($a$,$e$.agentes)) $\yluego$ ($a \in$ agentes($cs$) $\impluego$ \\
  (obtener($a$,$e$.agentes).sanciones = cantSanciones($a$,$cs$) $\land$\\
  obtener($a$,$e$.agentes).premios = cantHippiesAtrapados($a$,$cs$) $\land$\\
  obtener($a$,$e$.agentes).posicion = posAgente($a$,$cs$)))) $\yluego$ \\
  ($\forall n:$ nombre)(def?($n$,$e$.hippies) $\impluego$ posEstudianteYHippie($n$,$cs$) = obtener($a$,$e$.hippies)) $\land$\\
  (def?($n$,$e$.estudiantes) $\impluego$ posEstudianteYHippie($n$,$cs$) = obtener($a$,$e$.estudiantes)) }


\end{Representacion}


\begin{Algoritmos}

\begin{algorithm}[H]
\caption{Campus}

\begin{algorithmic}[1]
 \Procedure{iCampus}{\texttt{in} c : \texttt{estr}} $\to res$ : campus
  \State $res \gets$ $c$.cp \Comment $\Ogr(1)$
 \EndProcedure
\end{algorithmic}

 \underline{Complejidad:} $\Ogr(1)$
\end{algorithm}


\begin{algorithm}[H]
\caption{Estudiantes}

\begin{algorithmic}[1]
 \Procedure{iEstudiantes}{\texttt{in} c : \texttt{estr}} $\to res$ : itClavesDiccN(string)
  \State $res \gets$ CrearIt($c$.estudiantes) \Comment $\Ogr(1)$
 \EndProcedure
\end{algorithmic}
 \underline{Complejidad:} $\Ogr(1)$
\end{algorithm}


\begin{algorithm}[H]
\caption{Hippies}
\begin{algorithmic}[1]
	\Procedure{iHippies}{\texttt{in} c : \texttt{estr}} $\to res$ : itClavesDiccN(string)
	\State $res \gets$ CrearIt($c$.hippies) \Comment $\Ogr(1)$
	\EndProcedure
\end{algorithmic}
\underline{Complejidad:} $\Ogr(1)$
\end{algorithm}


\begin{algorithm}[H]
\caption{Agentes}
\begin{algorithmic}[1]
	\Procedure{iAgentes}{\texttt{in} c : \texttt{estr}} $\to res$ : itClavesDiccLog(nat)
	\State $res \gets$ CrearIt($c$.agentes) \Comment $\Ogr(1)$
	\EndProcedure
\end{algorithmic}
\underline{Complejidad:} $\Ogr(1)$
\end{algorithm}



\begin{algorithm}[H]
\caption{Posicion de Estudiante Y Hippie}

\begin{algorithmic}[1]
\Procedure{iPosEstudianteYHippie}{\texttt{in} c : \texttt{estr}, \texttt{in} n : \texttt{nombre}} $\to res$ : posicion
	\If{Definido($c$.hippies,$n$} \Comment $\Ogr(|h_m|)$
		\State $res \gets$ Obtener($n$,$c$.hippies) \Comment $\Ogr(|h_m|)$
	\Else
		\If{Definido($c$.estudiantes,$n$)} \Comment $\Ogr(|e_m|)$
			\State $res \gets$ Obtener($n$,$c$.estudiantes) \Comment $\Ogr(|e_m|)$
		\EndIf
	\EndIf	
 \EndProcedure
\end{algorithmic}

\underline{Complejidad:} $\Ogr(|n_m|)$ \\
\underline{Justificacion:} $h_m$ y $e_m$ son el hippie y estudiante con nombre mas largo, sea cual sea la rama del if a la que se entra la complejidad llega a ser 
$\Ogr(|n_m|)$ + $\Ogr(|n_m|)$ = $\Ogr(|n_m|)$ con $|n_m|$ = max($|h_m|$,$|e_m|$)
\end{algorithm}


\begin{algorithm}[H]
\caption{Posicion de Agente}
\begin{algorithmic}[1]
 \Procedure{iPosAgente}{\texttt{in} c : \texttt{estr}, \texttt{in} p : \texttt{placa}} $\to res$ : posicion
  \State $res \gets$ Obtener($c$.agentes, $pl$) \Comment $\Ogr(1)$ promedio
 \EndProcedure
\end{algorithmic}

 \underline{Complejidad:} $\Ogr(1)$ promedio
\end{algorithm}


\begin{algorithm}[H]
\caption{Cantidad de Sanciones}

\begin{algorithmic}[1]
\Procedure{iCantSanciones}{\texttt{in} c : \texttt{estr}, \texttt{in} pl : \texttt{placa}} $\to res$ : nat
	\State $res \gets$ Obtener($c$.agentes,$pl$).sanciones \Comment $\Ogr(1)$ promedio
\EndProcedure
\end{algorithmic}
\underline{Complejidad:} $\Ogr(1)$ promedio
\end{algorithm}


\begin{algorithm}[H]
\caption{Cantidad de Hippies Atrapados}
\begin{algorithmic}[1]
\Procedure{iCantHippiesAtrapados}{\texttt{in} c : \texttt{estr}, \texttt{in} pl : \texttt{placa}} $\to res$ : nat
	\State $res \gets$ Obtener($c$.agentes,$pl$).premios \Comment $\Ogr(1)$ promedio
\EndProcedure
\end{algorithmic}
\underline{Complejidad:} $\Ogr(1)$ promedio
\end{algorithm}


\begin{algorithm}[H]
\caption{Comenzar Rastrillaje}

\begin{algorithmic}[1]
\Procedure{iComenzarRastrillaje}{\texttt{in} c : \texttt{campus}, \texttt{in} d : \texttt{diccLineal(placa,posicion)}} $\to res$ : estr
	\State $res$.cp $\gets$ Copiar($c$) \Comment $\Ogr$($h*a$)
	\State $res$.posiciones.mAg $\gets$ CrearMatriz(Filas($c$),Columnas($c$), CrearItDiccLog()) \Comment $\Ogr$($h*a$)
	\State $res$.posiciones.mH $\gets$ CrearMatriz(Filas($c$),Columnas($c$), CrearItDiccN()) \Comment $\Ogr$($h*a$)
	\State $res$.posiciones.mE $\gets$ CrearMatriz(Filas($c$),Columnas($c$), CrearItDiccN()) \Comment $\Ogr$($h*a$)
	
	\State $res$.hippies $\gets$ Vacio() \Comment $\Ogr(1)$
	\State $res$.estudiantes $\gets$ Vacio() \Comment $\Ogr(1)$
	\State $res$.sanciones $\gets$ Vacio() \Comment $\Ogr(1)$
	\State $res$.agentesRapido $\gets$ Vacio($\#$Claves($d$)) \Comment $\Ogr(1)$
	\State $res$.agentes $\gets$ Vacio($\#$Claves($d$)) \Comment $\Ogr(1)$ %TODO, ver la complejidad
	\State itDicc(placa,posicion) $it$ $\gets$ CrearIt($d$) \Comment $\Ogr(1)$
	\If{HaySiguiente($it$)} \Comment $\Ogr(1)$
		\State conj(placa) $cp$ $\gets$ Vacio() \Comment $\Ogr(1)$
		\State itDicc(nat,conj(placa)) $itdic$ $\gets$ Definir(0,$cp$,$res$.sanciones) \Comment $\Ogr(1)$
		\State bool $f$ $\gets$ true \Comment $\Ogr(1)$
		\While{HaySiguiente($it$)} \Comment $n$ * $\Ogr(1)$
	 	\State placa $pl$ $\gets$ SiguienteClave($it$) \Comment $\Ogr(1)$
	 	\State posicion $pos$ $\gets$ CrearPosicion(X(SiguienteSignificado($it$)),Y(SiguienteSignificado($it$))) \Comment $\Ogr(1)$
	 	\State itConj(placa) $itc$ $\gets$ AgregarRapido($pl$,Obtener($res$.sanciones,0)) \Comment $\Ogr(n) + \Ogr(1)$
	 	\State datosAg $ag \gets \langle pl$,0,0,$pos$,$itdic$,$itc \rangle$ \Comment $\Ogr(1)$
	 	\State itDicLog(nat,datosAg) $itdl \gets$ DefinirLento($res$.agentes,$pl$,$ag$) \Comment $\Ogr(n)$
	 	\State $res$.posiciones.mAg[X($pos$)][Y($pos$)] $\gets itdl$ \Comment $\Ogr(1)$
	 	\State Definir($res$.agentesRapido,$pl$,$itdl$) \Comment $\Ogr(1)$ promedio
	 	\If{($f$ || $res$.masVigilante.placa $\geq pl$)} \Comment $\Ogr(1)$
	 		\State $res$.masVigilante.pl $\gets$ ag.pl \Comment $\Ogr(1)$
	 		\State $res$.masVigilante.premios $\gets$ ag.premios \Comment $\Ogr(1)$
	 		\State $f \gets$ false \Comment $\Ogr(1)$
	 	\EndIf
	 \EndWhile
	 \EndIf
\EndProcedure
\end{algorithmic}

\underline{Complejidad:} $\Ogr(h*a + n^2) + \Ogr(n)$ prom\\
Donde 
\begin{itemize}
	\item $h$ es Filas($c$)
	\item $a$ es Columnas($c$)
	\item $n$ es $\#$Claves($d$)
\end{itemize}	
\underline{Justificacion:} Sumo los $\Ogr(1)$ continuos para aclarar un poco ($C$*$\Ogr(1)$ = $\Ogr(1)$)\\
$4*\Ogr(h*a) + \Ogr(1) + n * \Ogr(1) * (\Ogr(n) + \Ogr(n) + \Ogr(1)$ prom = $\Ogr(h*a) + \Ogr(n)*(\Ogr(n) + \Ogr(1)$ prom = $\Ogr(h*a) + \Ogr(n^2) + \Ogr(n)$ prom = $\Ogr(h*a + n^2) + \Ogr(n)$ prom
\end{algorithm}


\begin{algorithm}[H]
\caption{Ingresar Estudiante}
\begin{algorithmic}[1]
\Procedure{iIngresarEstudiante}{\texttt{in/out} c : \texttt{estr}, \texttt{in} n : \texttt{nombre}, \texttt{in} p : \texttt{posicion}}
	\State $c$.pos.mE[X($p$)][Y($p$)] $\gets$ $\langle$true, Definir($c$.estudiantes,$n$,$p$)$\rangle$ \Comment $\Ogr(|e_m|)$
	\State enhippizar($c$, $p$) \Comment $\Ogr(|h_m|)$
	\State estudiantizar($c$, $p$) \Comment $\Ogr(|e_m|)$
	\State premiar($c$,$p$) \Comment $\Ogr(1)$
	\State capturar($c$,$p$) \Comment $\Ogr(|h_m|)$
	\State sancionar($c$,$p$) \Comment $\Ogr(1)$
\EndProcedure
\end{algorithmic}
\underline{Complejidad:} $\Ogr(|n_m|)$\\
\underline{Justificacion:} $\Ogr(|e_m|) + \Ogr(|h_m|) + \Ogr(|e_m|) + \Ogr(|h_m|)$ =  $\Ogr(2|e_m|) + \Ogr(|2h_m|)$ = $\Ogr(2max(|e_m|,|h_m|))$ = $\Ogr(|n_m|)$
\end{algorithm}


\begin{algorithm}[H]
\caption{Ingresar Hippie}
\begin{algorithmic}[1]
\Procedure{iIngresarHippie}{\texttt{in/out} c : \texttt{estr}, \texttt{in} n : \texttt{nombre}, \texttt{in} p : \texttt{posicion}}
	\State $c$.pos.mH[X($p$)][Y($p$)] $\gets$ $\langle$true, Definir($c$.hippies,$n$,$p$) $\rangle$ \Comment $\Ogr(1)$
	\State enhippizar($c$, $p$) \Comment $\Ogr(|h_m|)$
	\State premiar($c$,$p$) \Comment $\Ogr(1)$
	\State capturar($c$,$p$) \Comment $\Ogr(1)$
	\State sancionar($c$,$p$) \Comment $\Ogr(1)$
\EndProcedure
\end{algorithmic}
\underline{Complejidad:} $\Ogr(|n_m|)$ \\
\underline{Justificacion:} $\Ogr(|h_m|)$ = $\Ogr(|n_m|)$
\end{algorithm}

\begin{algorithm}[H]
\caption{Mover Estudiante}
\begin{algorithmic}[1]
\Procedure{iMoverEstudiante}{\texttt{in/out} c : \texttt{estr}, \texttt{in} n : \texttt{nombre}, \texttt{in} d : \texttt{direccion}}
	\State posicion $p \gets$ PosEstudianteYHippie($c$,$n$) \Comment $\Ogr(|n_m|)$
	\State $c$.pos.mE[X($p$)][Y($p$)].def $\gets$ false \Comment $\Ogr(1)$
	\State posicion $proxp \gets$ ProxPosicion($c$.cp,$p$,$d$) \Comment $\Ogr(1)$
	\If{EsIngreso($c$.cp,$proxp$)} \Comment $\Ogr(1)$
		\State EliminarSiguiente($c$.pos.mE[X($p$)][Y($p$)].dato) \Comment $\Ogr(|e_m|)$
	\Else
		\State $c$.pos.mE[X($proxp$)][Y($proxp$)].def $\gets$ true \Comment $\Ogr(1)$
		\State $c$.pos.mE[X($proxp$)][Y($proxp$)].dato $\gets$ $c$.pos.mE[X($p$)][Y($p$)].dato \Comment $\Ogr(1)$
	
		\State enhippizar($c$, $p$) \Comment $\Ogr(|h_m|)$
		\State estudiantizar($c$, $p$) \Comment $\Ogr(|e_m|)$
		\State premiar($c$,$p$) \Comment $\Ogr(1)$
		\State capturar($c$,$p$) \Comment $\Ogr(|h_m|)$
		\State sancionar($c$,$p$) \Comment $\Ogr(1)$
	\EndIf
\EndProcedure
\end{algorithmic}
\underline{Complejidad:} $\Ogr(|n_m|)$\\
\underline{Justificacion:} $\Ogr(|n_m|) + \Ogr(|h_m|) + \Ogr(|e_m|) + \Ogr(|h_m|)$ = $\Ogr(|n_m|) + \Ogr(2|h_m|) + \Ogr(|e_m|)$ = $\Ogr(|n_m|) + \Ogr(|e_m| + |h_m|)$ = $\Ogr(|n_m|) + \Ogr(|n_m|)$ = $\Ogr(|n_m|)$
\end{algorithm}


\begin{algorithm}[H]
\caption{Mover Hippie}
\begin{algorithmic}[1]
\Procedure{iMoverHippie}{\texttt{in/out} c : \texttt{estr}, \texttt{in} n : \texttt{nombre}}
	\State posicion $p \gets$ PosEstudianteYHippie($c$,$n$) \Comment $\Ogr(|n_m|)$
	\State $c$.pos.mH[X($p$)][Y($p$)].def $\gets$ false \Comment $\Ogr(1)$
	\State posicion $proxp \gets$ nuevaPosHippieOAgente($c$,$p$,CrearIt($c$.estudiantes)) \Comment $\Ogr(N_e)$
	\State $c$.pos.mH[X($proxp$)][Y($proxp$)].def $\gets$ true \Comment $\Ogr(1)$
	\State $c$.pos.mH[X($proxp$)][Y($proxp$)].dato $\gets$ $c$.pos.mH[X($p$)][Y($p$)].dato \Comment $\Ogr(1)$
	
	\State enhippizar($c$, $p$) \Comment $\Ogr(|h_m|)$
	\State premiar($c$,$p$) \Comment $\Ogr(1)$
	\State capturar($c$,$p$) \Comment $\Ogr(|h_m|)$
	\State sancionar($c$,$p$) \Comment $\Ogr(1)$
\EndProcedure
\end{algorithmic}
\underline{Complejidad:} $\Ogr(|n_m|) + \Ogr(N_e)$\\
\underline{Justificacion:} $\Ogr(|n_m|) + \Ogr(N_e) + \Ogr(|h_m|) + \Ogr(|h_m|)$ = $\Ogr(n_m) + \Ogr(N_e) +2\Ogr(|h_m|)$ = $\Ogr(|n_m|) + \Ogr(N_e) + 2\Ogr(|n_m|)$ = $3\Ogr(|n_m|) + \Ogr(N_e)$ = $\Ogr(|n_m|) + \Ogr(N_e)$
\end{algorithm}


\begin{algorithm}[H]
\caption{Mover Agente}
\begin{algorithmic}[1]
\Procedure{iMoverAgente}{\texttt{in/out} c : \texttt{estr}, \texttt{in} pl : \texttt{placa}}
	\State posicion $p \gets$ Obtener($c$.agentes,$pl$) \Comment $\Ogr(log N_a)$
	\State $c$.pos.mAg[X($p$)][Y($p$)].def $\gets$ false \Comment $\Ogr(1)$
	\State posicion $proxp \gets$ nuevaPosHippieOAgente($c$,$p$,CrearIt($c$.hippies)) \Comment $\Ogr(N_h)$
	\State $c$.pos.mAg[X($proxp$)][Y($proxp$)].def $\gets$ true \Comment $\Ogr(1)$
	\State $c$.pos.mAg[X($proxp$)][Y($proxp$)].dato $\gets$ $c$.pos.mAg[X($p$)][Y($p$)].dato \Comment $\Ogr(1)$
	
	\State premiar($c$,$p$) \Comment $\Ogr(1)$
	\State capturar($c$,$p$) \Comment $\Ogr(|h_m|)$
	\State sancionar($c$,$p$) \Comment $\Ogr(1)$
\EndProcedure
\end{algorithmic}
\underline{Complejidad:} $\Ogr(|n_m|) + \Ogr(log N_a) + \Ogr(N_h)$
\end{algorithm}


\begin{algorithm}[H]
\caption{Con K Sanciones}
\begin{algorithmic}[1]
\Procedure{iConKSanciones}{\texttt{in} c : \texttt{estr}, \texttt{in} k : \texttt{nat}} $\to res$:conj(placa)
	\If{Def($c$.sanciones,$k$)} \Comment $\Ogr(N_a)$ o $\Ogr(log N_a)$
		\State $res \gets$ Obtener($c$.sanciones,$k$) \Comment $\Ogr(log N_a)$
	\Else
		\State $res \gets$ Vacio() \Comment $\Ogr(1)$
	\EndIf
\EndProcedure
\end{algorithmic}
\underline{Complejidad:} $\Ogr(N_a)$ si hubo sanciones entre la ultima con K sanciones o $\Ogr(log N_a)$ si no.
\end{algorithm}

\begin{algorithm}[H]
\caption{Con Mismas Sanciones}
\begin{algorithmic}[1]
\Procedure{iConMismasSanciones}{\texttt{in} c : \texttt{estr}, \texttt{in} pl : \texttt{placa}} $\to res$:conj(placa)
	\State $res \gets$ SiguienteSignificado(Obtener($c$.agentesRapido,$pl$).kSanc) \Comment $\Ogr(1)$ promedio
\EndProcedure
\end{algorithmic}
\underline{Complejidad:} $\Ogr(1)$ promedio
\end{algorithm}


\begin{algorithm}[H]
\caption{Cantidad de Hippies}
\begin{algorithmic}[1]
\Procedure{iCantHippies}{\texttt{in} c : \texttt{estr}} $\to res$:nat
	\State $res \gets \#$Claves($c$.hippies) \Comment $\Ogr(1)$
\EndProcedure
\end{algorithmic}
\underline{Complejidad:} $\Ogr(1)$
\end{algorithm}

\begin{algorithm}[H]
\caption{Cantidad de Estudiantes}
\begin{algorithmic}[1]
\Procedure{iCantEstudiantes}{\texttt{in} c : \texttt{estr}} $\to res$:nat
	\State $res \gets \#$Claves($c$.estudiantes) \Comment $\Ogr(1)$
\EndProcedure
\end{algorithmic}
\underline{Complejidad:} $\Ogr(1)$
\end{algorithm}


\begin{algorithm}[H]
\caption{Mas Vigilante}
\begin{algorithmic}[1]
\Procedure{iMasVigilante}{\texttt{in} c : \texttt{estr}} $\to res$:placa
	\State $res \gets c$.masVigilante.pl \Comment $\Ogr(1)$
\EndProcedure
\end{algorithmic}
\underline{Complejidad:} $\Ogr(1)$
\end{algorithm}

\begin{algorithm}[H]
\caption{Nueva Posicion Hippie o Agente}
\begin{algorithmic}[1]
\Procedure{nuevaPosHippieOAgente}{\texttt{in} c : \texttt{estr}, \texttt{in} p : \texttt{posicion}, \texttt{in/out} itObj : \texttt{itDiccN(string,posicion)}}  $\to res$ : posicion
	\State nat $min \gets$ 0 \Comment $\Ogr(1)$
	\State posicion $objetivo$ \Comment $\Ogr(1)$
	\While{HaySiguiente($itObj$)} \Comment $n*\Ogr(1)$
		\If{$min$ == 0 || $min \geq$ DistanciaPosiciones($p$,SiguienteSignificado($itObj$))} \Comment $\Ogr(1)$
			\State $min \gets$ DistanciaPosiciones($p$,SiguienteSignificado($itObj$)) \Comment $\Ogr(1)$
			\State $objetivo \gets$ SiguienteSignificado($itObj$) \Comment $\Ogr(1)$
		\EndIf
		\State Avanzar($itObj$) \Comment $\Ogr(1)$
	\EndWhile
	\If{$min$ == 0} \Comment $\Ogr(1)$
		\State $objetivo \gets$ Siguiente(CrearIt(IngresosMasCercanos($c$.cp,$p$)))	 \Comment $\Ogr(1)$	
	\EndIf
	
	\State conj(posicion) $vecinosLibres \gets$ libres($c$,Vecinos($c$.cp,$p$)) \Comment $\Ogr(k)$
	\State itconj(posicion) $itVL \gets$ CrearIt($vecinosLibres$) \Comment $\Ogr(1)$
	\State $min \gets$ 0 \Comment $\Ogr(1)$
	\While{HaySiguiente($itVL$)} \Comment $m*\Ogr(1)$
		\If{$min$ == 0 || $min \geq$ DistanciaPosiciones($objetivo$,Siguiente($itVL$))}
			\State $min \gets$ DistanciaPosiciones($objetivo$,Siguiente($itVL$)) \Comment $\Ogr(1)$
			\State $res \gets$ Siguiente($itVL$) \Comment $\Ogr(1)$
		\EndIf
		\State Avanzar($itVL$) \Comment $\Ogr(1)$
	\EndWhile
\EndProcedure
\end{algorithmic}
\underline{Complejidad:} $\Ogr(n)$ siendo $n$ la cantidad de iteraciones de $itObj$ \\
\underline{Justificacion:} $n*Ogr(1)+\Ogr(k)+\Ogr(m)$ = $\Ogr(n+k+m)$\\
Donde
\begin{itemize}
	\item $n$ es la cantidad de iteraciones de $itObj$
	\item $m$ es la cantidad de posiciones libres de vecinos de una posicion, acotado por 4
	\item $k$ es la cantidad de vecinos de una posicion, acotado por 4
\end{itemize}
$\Ogr(n + 4 + 4)$ = $\Ogr(n + 8)$ = $\Ogr(n)$
\end{algorithm}


\begin{algorithm}[H]
\caption{Posiciones Libres}
\begin{algorithmic}[1]
\Procedure{libres}{\texttt{in} c : \texttt{estr}, \texttt{in} cp : \texttt{conj(posicion)}}  $\to res$ : conj(posicion)
	\State itconj(posicion) $itc \gets$ CrearIt($cp$) \Comment $\Ogr(1)$
	\State $res \gets$ Vacio() \Comment $\Ogr(1)$
	\While{HaySiguiente($itc$)} \Comment $n*\Ogr(1)$
		\If{!ocupada($c$,Siguiente($p$))} \Comment $\Ogr(1)$
			\State AgregarRapido($res$,Siguiente($p$)) \Comment $\Ogr(1)$
		\EndIf
		\State Avanzar($itc$) \Comment $\Ogr(1)$
	\EndWhile
\EndProcedure
\end{algorithmic}
\underline{Complejidad:} $\Ogr(n)$ siendo n $\#$Claves($cp$)
\end{algorithm}


\begin{algorithm}[H]
\caption{De estudiante a hippie}
\begin{algorithmic}[1]
	\Procedure{enhippizar}{\texttt{in/out} c : \texttt{estr}, \texttt{in} p : \texttt{posicion}}
	\State itConj(posicion) $itc$ $\gets$ CrearIt(AgregarRapido($p$,Vecinos($c$.cp,$p$))) \Comment $\Ogr(1)$
	\While {HaySiguiente($itc$)} \Comment $n+\Ogr(1)$
	\State posicion $p$ $\gets$ Siguiente($itc$) \Comment $\Ogr(1)$
		\If{esEstudiante($c$,$p$) $\&\&$ enhippizado($c$,$p$)} \Comment $\Ogr(1)$ 
			\State itDiccN(string,posicion) $itEaH \gets$ $c$.pos.mE[X($p$)][Y($p$)].dato \Comment $\Ogr(1)$
			\State EliminarSiguiente($itEaH$) \Comment $\Ogr(h_m)$
			\State $c$.pos.mE[X($p$)][Y($p$)].def $\gets$ false \Comment $\Ogr(1)$
			\State $c$.pos.mH[X($p$)][Y($p$)].def $\gets$ true \Comment $\Ogr(1)$
			\State $c$.pos.mH[X($p$)][Y($p$)].dato $\gets$ Definir($c$.hippies,$n$,$p$) \Comment $\Ogr(|h_m|)$
		\EndIf
		\State Avanzar($itc$) \Comment $\Ogr(1)$
	\EndWhile
	\EndProcedure
\end{algorithmic}
\underline{Complejidad:} $\Ogr(|h_m|)$\\
\underline{Justificacion:} $\Ogr(1) + (n*\Ogr(1))* 2\Ogr(|h_m|)$ = $\Ogr(n)*2\Ogr(|h_m|)$ con $n$ siendo la cantidad de vecinos + 1, acotado por 5. \\
$\Ogr(5)*2\Ogr(|h_m|)$ = $\Ogr(|h_m|)$
\end{algorithm}

\begin{algorithm}[H]
\caption{De hippie a estudiante}
\begin{algorithmic}[1]
	\Procedure{estudiantizar}{\texttt{in/out} c : \texttt{estr}, \texttt{in} p : \texttt{posicion}}
	\State itConj(posicion) $itc$ $\gets$ CrearIt(AgregarRapido($p$,Vecinos($c$.cp,$p$))) \Comment $\Ogr(1)$
	\While {HaySiguiente($itc$)} \Comment $n + \Ogr(1)$
	\State posicion $p$ $\gets$ Siguiente($itc$) \Comment $\Ogr(1)$
	\If{esHippie($c$,$p$) $\&\&$ estudiantizado($c$,$p$)} \Comment $\Ogr(1)$
		\State itDiccN(string,posicion) $itHaE \gets$ $c$.pos.mH[X($p$)][Y($p$)] \Comment $\Ogr(1)$
		\State EliminarSiguiente($itHaE$) \Comment $\Ogr(|e_m|)$
		\State $c$.pos.mH[X($p$)][Y($p$)].def $\gets$ false \Comment $\Ogr(1)$
		\State $c$.pos.mE[X($p$)][Y($p$)].def $\gets$ true \Comment $\Ogr(1)$
		\State $c$.pos.mE[X($p$)][Y($p$)].dato $\gets$ Definir($c$.estudiantes,$n$,$p$) \Comment $\Ogr(|e_m|)$
	\EndIf
	\EndWhile
	\EndProcedure
\end{algorithmic}
\underline{Complejidad:} $\Ogr(|e_m|)$\\
\underline{Justificacion:} $\Ogr(1) + (n*\Ogr(1))* 2\Ogr(|e_m|)$ = $\Ogr(n)*2\Ogr(|e_m|)$ con $n$ siendo la cantidad de vecinos + 1, acotado por 5. \\
$\Ogr(5)*2\Ogr(|e_m|)$ = $\Ogr(|e_m|)$
\end{algorithm}



\begin{algorithm}[H]
\caption{Premiar Agentes}
\begin{algorithmic}[1]
	\Procedure{premiar}{\texttt{in/out} c : \texttt{estr}, \texttt{in} p : \texttt{posicion}}
	\If{rodeado($c$,$p$) $\&\&$ esHippie($c$,$p$) $\&\&$ $\#$Claves(agentes($c$,Vecinos($c$.cp,$p$))} \Comment $\Ogr(k)$
			\State itConj(posicion) $itca \gets$ agentes($c$,Vecinos($c$.cp,$p$)) \Comment $\Ogr(k)$
			\While{HaySiguiente($itca$)} \Comment $n*\Ogr(1)$
				\State Siguiente($c$.pos.mAg[X($p$)][Y($p$)]).premios ++ \Comment $\Ogr(1)$
				\State actualizarMasVigilante($c$,pos.mAg[X($p$)][Y($p$)]) \Comment $\Ogr(1)$
				\State Avanzar($itca$) \Comment $\Ogr(1)$
			\EndWhile
	\Else
	\State itConj(posicion) $itc$ $\gets$ CrearIt(Vecinos($c$.cp, $p$)) \Comment $\Ogr(1)$
	\While {HaySiguiente($itc$)} \Comment $n*\Ogr(1)$
	\State posicion $p$ $\gets$ Siguiente($itc$) \Comment $\Ogr(1)$
		\If{rodeado($p$) $\&\&$ esHippie($p$)} \Comment $\Ogr(1)$
			\State itConj(posicion) $itca \gets$ agentes($c$,Vecinos($c$.cp,$p$)) \Comment $\Ogr(k)$
			\While{HaySiguiente($itca$)} \Comment $m*\Ogr(1)$
				\State $pa \gets$ Siguiente($itca$) \Comment $\Ogr(1)$
				\State Siguiente(pos.mAg[X($pa$)][Y($pa$)]).premios ++ \Comment $\Ogr(1)$
				\State actualizarMasVigilante($c$,pos.mAg[X($pa$)][Y($pa$)]) \Comment $\Ogr(1)$
				\State Avanzar($itca$) \Comment $\Ogr(1)$
			\EndWhile
		\EndIf
	\EndWhile
	\EndIf
	\EndProcedure
\end{algorithmic}
\underline{Complejidad:} $\Ogr(1)$\\
\underline{Justificacion:} $\Ogr(1) + n*\Ogr(1)*(\Ogr(k) + m\Ogr(1))$ = $\Ogr(n*(k + m))$\\
Donde
\begin{itemize}
	\item $n$ es la cantidad de vecinos de una posicion, acotado por 4
	\item $m$ es la cantidad de agentes vecinos de una posicion, acotado por 4
	\item $k$ es la cantidad de vecinos de una posicion, acotado por 4
\end{itemize}
$\Ogr(4*(4+4))$ = $\Ogr(32)$ = $\Ogr(1)$
\end{algorithm}


\begin{algorithm}[H]
\caption{Capturar Hippies}
\begin{algorithmic}[1]
	\Procedure{capturar}{\texttt{in/out} c : \texttt{estr}, \texttt{in} p : \texttt{posicion}}
	\If{rodeado($c$,$p$) $\&\&$ esHippie($c$,$p$) $\&\&$ $\#$Claves(agentes($c$,Vecinos($c$.cp,$p$)) $\geq$ 1} \Comment $\Ogr(k)$
			\State itDiccN(string,posicion) $itH \gets$ $res$.pos.mH[X($p$)][Y($p$)] \Comment $\Ogr(1)$
			\State EliminarSiguiente($itH$) \Comment $\Ogr(|h_m|)$
			\State $res$.pos.mE[X($p$)][Y($p$)].def $\gets$ false \Comment $\Ogr(1)$
	\Else
	\State itConj(posicion) $itc$ $\gets$ CrearIt(Vecinos($c$.cp,$p$)) \Comment $\Ogr(1)$
	\While {HaySiguiente($itc$)} \Comment $n*\Ogr(1)$
		\State posicion $p$ $\gets$ Siguiente($itc$) \Comment $\Ogr(1)$
		\If{rodeado($c$,$p$) $\&\&$ esHippie($c$,$p$) $\&\&$ $\#$Claves(agentes($c$,Vecinos($c$.cp,$p$))) $\geq$ 1} \Comment $\Ogr(k)$
			\State itDiccN(string,posicion) $itH \gets$ $c$.pos.mH[X($p$)][Y($p$)] \Comment $\Ogr(1)$
			\State EliminarSiguiente($itH$) \Comment $\Ogr(|h_m|)$
			\State $c$.pos.mE[X($p$)][Y($p$)].def $\gets$ false \Comment $\Ogr(1)$
		\EndIf
		\State Avanzar($itc$) \Comment $\Ogr(1)$
	\EndWhile
	
	\EndIf
	\EndProcedure
\end{algorithmic}
\underline{Complejidad:} $\Ogr(|h_m|)$\\
\underline{Justificacion:} $\Ogr(k) + n*\Ogr(1)*(\Ogr(|h_m|) + \Ogr(k))$ = $\Ogr(k) + \Ogr(n)*\Ogr(|h_m|+ k)$ = $\Ogr(k) + \Ogr(n*|h_m| + n*k)$ = $\Ogr(n*|h_m| + n*k)$ ($n*k > k$)\\
Donde
\begin{itemize}
	\item $n$ es la cantidad de vecinos de una posicion, acotado por 4
	\item $|h_m|$ es el hippie con nombre mas largo
	\item $k$ es la cantidad de vecinos de una posicion, acotado por 4
\end{itemize}
$\Ogr(4*|h_m| + 4*4)$ = $\Ogr(4*|h_m| + 16)$ = $\Ogr(4*|h_m|)$ = $\Ogr(|h_m|)$
\end{algorithm}

\begin{algorithm}[H]
\caption{Sancionar Agentes}
\begin{algorithmic}[1]
	\Procedure{sancionar}{\texttt{in/out} c : \texttt{estr}, \texttt{in} p : \texttt{posicion}}
	
	\State itConj(posicion) $itc$ $\gets$ CrearIt(AgregarRapido($p$,Vecinos($c$.cp,$p$)) \Comment $\Ogr(1)$
	\While {HaySiguiente($itc$)} \Comment $n*\Ogr(1)$
		\State posicion $p$ $\gets$ Siguiente($itc$) \Comment $\Ogr(1)$
		\State conj(posicion) $cag \gets$ agentes($c$,Vecinos($c$.cp,$p$) \Comment $\Ogr(k)$
		\If{rodeado($c$,$p$) $\&\&$ esEstudiante($c$,$p$) $\&\&$ $\#$Claves($cag$) $\geq$ 1} \Comment $\Ogr(1)$
		\State itConj(posicion) $itca \gets cag$ \Comment $\Ogr(1)$
			\While{HaySiguiente($itca$)} \Comment $m*\Ogr(1)$
				\State posicion $pa \gets$ Siguiente($itca$) \Comment $\Ogr(1)$
				\State Siguiente($c$.pos.mAg[X($pa$)][Y($pa$)]).dato).sanciones ++ \Comment $\Ogr(1)$
				\State datosAg $datos \gets$ Siguiente($c$.pos.mAg[X($pa$)][Y($pa$)]).dato \Comment $\Ogr(1)$
				\State EliminarSiguiente($datos$.mismasSanc) \Comment $\Ogr(1)$
				\If{$\#$(SiguienteSignificado($datos$.kSanc)) == 0} \Comment $\Ogr(1)$
					\State EliminarSiguiente($datos$.kSanc) \Comment $\Ogr(1)$
				\EndIf
				\If{$datos$.sanciones $<$ SiguienteClave($datos$.kSanc)} \Comment $\Ogr(1)$
					\State InsertarAdelante($datos$.kSanc,$datos$.sanciones,Vacio()) \Comment $\Ogr(1)$
				\Else
					\State Avanzar($datos$.kSanc) \Comment $\Ogr(1)$
				\EndIf
				\State $datos$.mismasSanc $\gets$ AgregarRapido(SiguienteSignificado($datos$.kSanc),$datos$.pl) \Comment $\Ogr(1)$
			\EndWhile
			
		\EndIf
		\State Avanzar($itc$) \Comment $\Ogr(1)$
	\EndWhile
	\EndProcedure
\end{algorithmic}
\underline{Complejidad:} $\Ogr(1)$\\
\underline{Justificacion:} $n*(\Ogr(k) + m*\Ogr(1))$ = $\Ogr(n)*\Ogr(k+m)$ = $\Ogr(n*k + n*m)$\\
Donde
\begin{itemize}
	\item $n$ es la cantidad de vecinos de una posicion + 1, acotado por 5
	\item $m$ es la cantidad de agentes vecinos de una posicion, acotado por 4
	\item $k$ es la cantidad de vecinos de una posicion, acotado por 4
\end{itemize}
$\Ogr(5*4 + 5*4)$ = $\Ogr(40)$ = $\Ogr(1)$

\end{algorithm}


\begin{algorithm}[H]
\caption{¿Se transforma en hippie?}
\begin{algorithmic}[1]
	\Procedure{enhippizado}{\texttt{in} c : \texttt{estr}, \texttt{in} p : \texttt{posicion}} $\to res$ : bool
	\State $res \gets$ false \Comment $\Ogr(1)$
	\State itConj(posicion) $itc$ $\gets$ CrearIt(Vecinos($c$.cp, $p$)) \Comment $\Ogr(1)$
	\State nat $i \gets 0$ \Comment $\Ogr(1)$
	\While{HaySiguiente($itc$)} \Comment $n * \Ogr(1)$
		\If{esHippy($c$,Siguiente($itc$))} \Comment $\Ogr(1)$
			\State $i \gets i+1$ \Comment $\Ogr(1)$
		\EndIf
		\State Avanzar($itc$) \Comment $\Ogr(1)$
	\EndWhile
	$res \gets (i \geq 2)$ \Comment $\Ogr(1)$
	\EndProcedure
\end{algorithmic}
\underline{Complejidad:} $\Ogr(1)$\\
\underline{Justificacion:} $\Ogr(1) + n * \Ogr(1)$ =  $\Ogr(n)$ siendo $n$ la cantidad de vecinos, que como maximo es 4 \\
$\Ogr(4)$ = $\Ogr(1)$
\end{algorithm}


\begin{algorithm}[H]
\caption{¿Es hippie?}
\begin{algorithmic}[1]
	\Procedure{esEstudiante}{\texttt{in} c : \texttt{estr}, \texttt{in} p : \texttt{posicion}} $\to res$ : bool
	\State $res \gets$ $c$.pos.mH[X($p$)][Y($p$)].def \Comment $\Ogr(1)$
	\EndProcedure
\end{algorithmic}
\underline{Complejidad:} $\Ogr(1)$
\end{algorithm}


\begin{algorithm}[H]
\caption{¿Se transforma en estudiante?}
\begin{algorithmic}[1]
	\Procedure{enhippizado}{\texttt{in} c : \texttt{estr}, \texttt{in} p : \texttt{posicion}} $\to res$ : bool
	\State $res \gets$ false \Comment $\Ogr(1)$
	\State itConj(posicion) $itc$ $\gets$ CrearIt(Vecinos($c$.cp, $p$)) \Comment $\Ogr(1)$
	\State nat $i \gets 0$ \Comment $\Ogr(1)$
	\While{HaySiguiente($itc$)}  \Comment $n*\Ogr(1)$
		\If{esEstudiante(Siguiente($itc$))}  \Comment $\Ogr(1)$
			\State $i \gets i+1$  \Comment $\Ogr(1)$
		\EndIf
		\State Avanzar($itc$)  \Comment $\Ogr(1)$
	\EndWhile
	$res \gets (i = 4)$  \Comment $\Ogr(1)$
	\EndProcedure
\end{algorithmic}
\underline{Complejidad:} $\Ogr(1)$\\
\underline{Justificacion:} $\Ogr(1) + n * \Ogr(1)$ =  $\Ogr(n)$ siendo $n$ la cantidad de vecinos, que como maximo es 4 \\
$\Ogr(4)$ = $\Ogr(1)$
\end{algorithm}


\begin{algorithm}[H]
\caption{¿Es estudiante?}
\begin{algorithmic}[1]
	\Procedure{esEstudiante}{\texttt{in} c : \texttt{estr}, \texttt{in} p : \texttt{posicion}} $\to res$ : bool
	\State $res \gets$ $c$.pos.mE[X($p$)][Y($p$)].def \Comment $\Ogr(1)$
	\EndProcedure
\end{algorithmic}
\underline{Complejidad:} $\Ogr(1)$
\end{algorithm}


\begin{algorithm}[H]
\caption{¿Esta Rodeado?}
\begin{algorithmic}[1]
	\Procedure{rodeado}{\texttt{in} c : \texttt{estr}, \texttt{in} p : \texttt{posicion}} $\to res$ : bool
	\State itConj(posicion) $itc$ $\gets$ CrearIt(Vecinos($c$.cp, $p$)) \Comment $\Ogr(1)$
	\State nat $i \gets$ 0 \Comment $\Ogr(1)$
		\While{HaySiguiente($itc$)} \Comment $n*\Ogr(1)$
			\If{ocupado(Siguiente($p$))} \Comment $\Ogr(1)$
				\State $i$++ \Comment $\Ogr(1)$
			\EndIf
			Avanzar($itc$) \Comment $\Ogr(1)$
		\EndWhile
		$res \gets (i==4)$ \Comment $\Ogr(1)$
	\EndProcedure
\end{algorithmic}
\underline{Complejidad:} $\Ogr(1)$\\
\underline{Justificacion:} $n*\Ogr(1)$ = $\Ogr(n)$ siendo n la cantidad de vecinos de una posicion, con cota 4\\
$\Ogr(4)$ = $\Ogr(1)$
\end{algorithm}



\begin{algorithm}[H]
\caption{¿Esta Ocupado?}
\begin{algorithmic}[1]
	\Procedure{rodeado}{\texttt{in} c : \texttt{estr}, \texttt{in} p : \texttt{posicion}} $\to res$ : bool
	\State $res \gets$ (esHippie($c$,$p$) || esAgente($c$,$p$) || esEstudiante($c$,$p$) || Ocupada($c$.cp,$p$)) \Comment $\Ogr(1)$
	\EndProcedure
\end{algorithmic}
\underline{Complejidad:} $\Ogr(1)$
\end{algorithm}

\begin{algorithm}[H]
\caption{Agentes en posiciones}
\begin{algorithmic}[1]
	\Procedure{agentes}{\texttt{in} c : \texttt{estr}, \texttt{in} cp : \texttt{conj(posicion)}} $\to res$ : conj(posicion)
	\State itConj(posicion) $itc$ $\gets$ CrearIt($cp$) \Comment $\Ogr(1)$
	$res \gets $Vacio();
	\While{HaySiguiente($itc$)} \Comment $n*\Ogr(1)$
			\If{esAgente(Siguiente($p$))} \Comment $\Ogr(1)$
				\State AgregarRapido($res$,$p$) \Comment $\Ogr(1)$
			\EndIf
			Avanzar($itc$) \Comment $\Ogr(1)$
		\EndWhile
	\EndProcedure
\end{algorithmic}
\underline{Complejidad:} $\Ogr(n)$ siendo $n$ = $\#$(Claves($cp$))
\end{algorithm}


\begin{algorithm}[H]
\caption{¿Es agente?}
\begin{algorithmic}[1]
	\Procedure{esAgente}{\texttt{in} c : \texttt{estr}, \texttt{in} p : \texttt{posicion}} $\to res$ : bool
	\State $res \gets$ $c$.pos.mAg[X($p$)][Y($p$)].def \Comment $\Ogr(1)$
	\EndProcedure
\end{algorithmic}
\underline{Complejidad:} $\Ogr(1)$
\end{algorithm}


\begin{algorithm}[H]
\caption{Actualizar mas Vigilante}
\begin{algorithmic}[1]
	\Procedure{actualizarVigilante}{\texttt{in/out} c : \texttt{estr}, \texttt{in} datos : \texttt{datosAg}}
	\If{$datos$.premios $> c$.masVigilante.premios} \Comment $\Ogr(1)$
		\State $c$.masVigilante.pl $\gets datos$.pl	\Comment $\Ogr(1)$		
		\State $c$.masVigilante.premios $\gets datos$.premios \Comment $\Ogr(1)$
	\EndIf
	\If{$datos$.premios == $c$.masVigilante.premios} \Comment $\Ogr(1)$
		\If{$datos$.pl $< c$.masVigilante.pl} \Comment $\Ogr(1)$
			\State $c$.masVigilante.pl $\gets datos$.pl	\Comment $\Ogr(1)$		
			\State $c$.masVigilante.premios $\gets datos$.premios \Comment $\Ogr(1)$
		\EndIf
	\EndIf
	\EndProcedure
\end{algorithmic}
\underline{Complejidad:} $\Ogr(1)$
\end{algorithm}

\end{Algoritmos}
