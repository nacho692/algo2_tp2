\begin{Interfaz}

	\textbf{se explica con}: \tadNombre{Diccionario(nat, conj(placa))}.

	\textbf{usa}: nat, bool, conj(placa)

	\textbf{géneros}: \TipoVariable{diccS}.

	\tituloModulo{Operaciones básicas de diccionario de sanciones}

	\InterfazFuncion{CrearDiccS}{\In{significado}{conj(placa)}}{diccS}
	{$res \igobs$ definir($0$, significado, vacio)}
	[$\Ogr$(1)]
	[Genera un diccionario con todos los agentes con $0$ sanciones.]

	\InterfazFuncion{Definir}{\Inout{ds}{diccS}, \In{s}{nat}, \In{significado}{conj(placa)}}{its}
	[ds$_0$=ds $\land$ ($\forall$ i: nat) i $\in$ claves(ds) $\Rightarrow$ s $>$ i]
	{(ds $\igobs$ definir(s, significado, ds)) $\land$ haySiguiente($res$) $\land_l$ siguiente($res$)=$<$s, significado$>$ $\land$\\
	secuSuby($res$)$\igobs$ordenar$\pi$1(secuenciarDic(ds))}%uso el definir de diccLineal
	[$\Ogr$(1)]
	[defino la clave $s$ con el significado $significado$ en mi diccionario $ds$]
	
	\InterfazFuncion{Obtener}{\Inout{ds}{diccS}, \In{s}{nat}}{conj(placa)}
	{$res \igobs$ obtener(s, ds)}
	[$\Ogr$(1)]
	[me retorna el conjunto de placas con $s$ sanciones del $ds$]

	\InterfazFuncion{Def?}{\In{ds}{diccS}, \In{s}{nat}}{bool}
	[def?(s, ds)]
	{$res \igobs$ def?(s, ds)}  
	[$\Ogr$(1)]
	[me dice si esta definida la clave $s$ en el diccionario $ds$]
	
\end{Interfaz}

\begin{Representacion}
	
	\tituloModulo{Representacion del Diccionaro de Sanciones}
	\begin{Estructura}{diccS}
		\begin{Tupla}
			\tupItem{lista}{lista(tupla(c : nat,s :conj(placa)))}
			\tupItem{diccLog}{diccLog(nat, con(placa))}
			\tupItem{actualizar}{bool}
		\end{Tupla}
	\end{Estructura}
	
	\begin{enumerate}
		\item La lista esta ordenada por su primer elemento
		\item No hay repetidos en la lista del primer elemento de la tupla
		\item Si actualizar esta en false, las tuplas de la lista son tuplas clave, significado del diccionario logaritmico y vice versa
	\end{enumerate}
	
	\Rep{
	($\forall i$: nat)($i \leq$longitud(e.lista)-2)$\pi_1$(e.lista[$i$]) < $\pi_1$($e$.lista[$i+1$]) $\land$ \\
	$\neg e$.actualizar $\implies$ \\
	($\forall c$: nat)($\forall s$:conj(nat))(esta?($\langle$c,s$\rangle)$,e.lista) $\iff$ def?($c$,$e$.diccLog) $\yluego s$ = obtener($c$,$e$.diccLog))}
	
%	\Rep{ClavesOrdenadas(e.lista) $land$ SinClavesRepetidas(e.lista)$\land$\\
%	($\neg$e.actualizar $\Rightarrow$ (longitud(e.lista) $\igobs$ %$\#$(claves(e.diccLog)) \\
%	$\yluego$ (($\forall$ n: nat)(n $\in$ claves(e.diccLog) $\iff$ n $\in$ %Claves(e.lista))\\
%	$\yluego$ (($\forall$ cp: conj(placa)) cp$=$obtener(n, e.diccLog)\\
%	$\iff$ ($\exists$ i: nat) cp$=$significado(e.lista[i]) $\land$ n $\igobs$ %clave(e.lista[i])))))
	%}
%	
%	\tadOperacion{Significados}{diccLog(nat, conj(placa))}{conj(conj((placa)))}{}
%	\tadAxioma{Significados(d)}{\IF $\#$claves(d)$=0$
%		THEN $\emptyset$
%		ELSE Ag(obtener(dameUno(claves(d)), Significados(borrar(dameUno(claves(d)),d)))
%		FI}
%
%	
%	~	
%	
%	\tadOperacion{Union}{conj(conj(plc))}{conj(plc)}{}
%	\tadAxioma{Union(c)}{\IF $\#$c$=0$
%		THEN $\emptyset$
%		ELSE dameUno(c)$\cup$Union(sinUno(c))
%		FI}
%	
	~
	
	
	\AbsFc{diccS}{d : diccS $/$ \\
		($\forall n$ : nat)($\forall s$ : conj(placa) (esta?($\langle$c,s$\rangle)$,e.lista) $\iff$ def?($n$, $d$)) \\
		$\yluego$ (def?($c$, $d$) $\impluego$ obtener($d$) = $s$))}
	

\begin{Algoritmos}
	
	\begin{algorithm}[H]
		\caption{iCrearDiccS}
		\begin{algorithmic}[1]
			\Procedure{iCrearDiccS}{\texttt{in} sig : \texttt{conj(placa)}} $\to res$ : estr
			\State $res$.diccLog$\leftarrow$ Vacio($\#$(sig)) //vacio de diccionario logaritmico \Comment $\Ogr$(1)
			\State $res$.lista$\leftarrow$ Vacia() //vacia de lista enlazada \Comment $\Ogr$(1)
			\State $res$.actualizar $\leftarrow$ false \Comment $\Ogr$(1) 
			\EndProcedure
		\end{algorithmic}
		\underline{Complejidad:} $\Ogr$(1)
	\end{algorithm}
	
	\begin{algorithm}[H]
		\caption{iDefinir}
		\begin{algorithmic}[1]
			\Procedure{iDefinir}{\texttt{in/out} e : \texttt{estr}, \texttt{in} s : \texttt{nat}, \texttt{in} sig : \texttt{conj(placa)}} $\to res$ : itDic
			\State itLista $it \gets$ AgregarAtras(e.lista, s, sig) //agregar atras de lista enlazada \Comment $\Ogr$($\#$sig)
			\State $res \gets$ it \Comment $\Ogr$(1)
			\State e.actualizar $\gets$ true \Comment $\Ogr$(1) 
			\EndProcedure
		\end{algorithmic}
		\underline{Complejidad:} $\Ogr$($\#$(sig))
	\end{algorithm}

	\begin{algorithm}[H]
		\caption{iObtener}
		\begin{algorithmic}[1]
			\Procedure{iObtener}{\texttt{in/out} e : \texttt{estr}, \texttt{in} s : \texttt{nat}} $\to res$ : conj(placa)
			\If{e.actualizar} \Comment $\Ogr$(1)
				\State it $\gets$ CrearIt(e) \Comment $\Ogr$(1)
				\While{HaySiguiente(it)} // $\Ogr$(1) cantidad de clavesDeLista veces \Comment $\Ogr$($\#$Claves(e.lista))
					\State e.diccLog $\gets$ Definir(e.diccLog, SiguienteClave(it), SiguienteSignificado(it)) //Definir de diccLog \Comment $\Ogr$(1) 
					\State avanzar(it) \Comment $\Ogr$(1) 
				\EndWhile
				\State e.actualizar $\gets$ false \Comment $\Ogr$(1) 
			\EndIf
			\State Obtener(e.diccLog, s) $\Ogr$(1)
			\EndProcedure
		\end{algorithmic}
		\underline{Complejidad:} $\Ogr$($\#$claves(e.lista)) o $\Ogr$($log$ $\#$claves(e.lista))\\
		
		\underline{Justificacion:} $\Ogr$($\#$claves(e.lista))+$\Ogr$(log $\#$claves(e.lista)). En el peor de los casos sera la $\Ogr$($\#$claves(e.lista)) pues $\Ogr$($\#$claves(e.diccLog))$>\Ogr$(log $\#$claves(e.lista)). Y en el peor de los casos $\#$claves(e.diccLog) sera igual a la cantidad de agentes (esto sera cuando todos los agentes tengan diferentes sanciones). Cuando la cantidad de sanciones se mantenga (e.actualizar $=$ false) entonces tendremos una complejidad de $\Ogr$(log $\#$claves(e.lista)) puesto que nunca entraremos en el while.
	\end{algorithm}	
	
	\begin{algorithm}[H]
		\caption{iDef?}
		
		\begin{algorithmic}[1]
			\Procedure{iDef?}{\texttt{in} e : \texttt{estr}, \texttt{in} s : \texttt{nat}} $\to res$ : bool
			\If{e.actualizar} \Comment $\Ogr$(1)
			\State it $\gets$ CrearIt(e) \Comment $\Ogr$(1)
			\While{HaySiguiente(it)} // $\Ogr$(1) cantidad de clavesDeLista veces \Comment $\Ogr$($\#$Claves(e.lista))
			\State e.diccLog $\gets$ Definir(e.diccLog, SiguienteClave(it), SiguienteSignificado(it)) //Definir de diccLog \Comment $\Ogr$(1) 
			\State avanzar(it) \Comment $\Ogr$(1) 
			\EndWhile
			\State e.actualizar $\gets$ false \Comment $\Ogr$(1) 
			\EndIf
			\State Definido(e.diccLog, s) //Definido? de diccLog$\Ogr$(1)
			\EndProcedure
		\end{algorithmic}
		\underline{Complejidad:} $\Ogr$($\#$claves(e.lista))
		\underline{Justificacion:}Semejante a la justificacion de iObtener
		
	\end{algorithm}

\end{Algoritmos}
\end{Representacion}