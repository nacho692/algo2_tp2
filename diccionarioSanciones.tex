\begin{Interfaz}

	\textbf{se explica con}: \tadNombre{Diccionario(nat, conj(placa)), Iterador Bidireccional($\alpha$)}.

	\textbf{géneros}: \TipoVariable{diccS, its}.

	\tituloModulo{Operaciones básicas de diccionario de sanciones}

	\InterfazFuncion{CrearDiccS}{\In{significado}{conj(placa)}}{diccS}
	{$res \igobs$ definir($0$, significado, vacio)}
	[$\Ogr$(1)]
	[genera un diccionario con todos los agentes con $0$ sanciones]

	\InterfazFuncion{Definir}{\Inout{ds}{diccS}, \In{s}{nat}, \In{significado}{conj(placa)}}{its}
	[ds$_0$=ds $\land$ ($\forall$ i: nat) i $\in$ claves(ds) $\Rightarrow$ s $\geq$ i]
	{(ds $\igobs$ definir(s, significado, ds)) $\land$ haySiguiente($res$) $\land_l$ siguiente($res$)=$<$s, significado$>$ $\land$\\
	secuSuby($res$)$\igobs$ordenar$\pi$1(secuenciarDic(ds))}%uso el definir de diccLineal
	[$\Ogr$(1)]
	[defino la clave $s$ con el significado $significado$ en mi diccionario $ds$]
	
	\InterfazFuncion{Obtener}{\Inout{ds}{diccS}, \In{s}{nat}}{conj(placa)}
	{$res \igobs$ obtener(s, ds)}
	[$\Ogr$(1)]
	[me retorna el conjunto de placas con $s$ sanciones del $ds$]

	\InterfazFuncion{Def?}{\In{ds}{diccS}, \In{s}{nat}}{bool}
	[def?(s, ds)]
	{$res \igobs$ def?(s, ds)}  
	[$\Ogr$(1)]
	[me dice si esta definida la clave $s$ en el diccionario $ds$]
	
	
	\tituloModulo{Operaciones básicas de iterador de sanciones}
	
	Para simplificar las cosas usaremos clave y significado en vez de $\Pi1$ y $\Pi2$ cuanto utilicemos una tupla(nat, conj(placa))
	
	\InterfazFuncion{CrearIts}{\In{ds}{diccS}}{itS}
	{SecuSuby($res$)$\igobs$ordenar$\pi1$(secuenciarDic(ds))}
	[$\Ogr$(1)]
	[crea iterador de sanciones]
	
	\InterfazFuncion{HaySiguiente}{\In{its}{itS}}{bool}
	{$res \igobs$ haySiguiente?(its)}
	[$\Ogr$(1)]
	[me retorna true si hay quedan elementos para avanzar]
	
	\InterfazFuncion{Siguiente}{\In{its}{itS}}{tupla(nat, conj(placa))}
	[haySiguiente?(its)]
	{alias($res \igobs$ siguiente(its))}
	[$\Ogr$(1)]
	[devuelve el elemento siguiente del iterador]
	
	\InterfazFuncion{SiguienteClave}{\In{its}{itS}}{nat}
	[haySiguiente?(its)]
	{alias($res \igobs$ siguiente(its).clave)}
	{$\Ogr$(1)}
	{devuelve la clave del siguiente iterador}
	
	\InterfazFuncion{SiguienteSignificado}{\In{its}{itS}}{conj(placa)}
	[haySiguiente?(its)]
	{alias($res \igobs$ siguiente(its).significado)}
	{$\Ogr$(1)}
	{devuelve el significado del siguiente iterador}


\end{Interfaz}

\begin{Representacion}
	
	\tituloModulo{Representacion del Diccionaro de Sanciones}
	\begin{Estructura}{diccS}
		\begin{Tupla}
			\tupItem{diccLineal}{dicc(nat, conj(placa))}
			\tupItem{diccLog}{diccLog(nat, con(placa))}
			\tupItem{actualizar}{bool}
		\end{Tupla}
	\end{Estructura}
	
	\Rep{$\neg$e.actualizar $\Rightarrow$ (($\forall$ n: nat)(n $\in$ claves(e.diccLog) $\iff$ n $\in$ claves(e.diccLineal))$\land_l$ ($\forall$ cp: conj(placa)) cp$=$obtener(n, e.diccLog)$\iff$ cp$=$obtener(n, e.diccLineal))
		\\
		$\land$e.actualizar$\Rightarrow$ Union(Significados(e.diccLog))$=$Union(Significados(e.diccLineal))}
	
	\tadOperacion{Significados}{dicc(nat, conj(placa))}{conj(conj((placa)))}{}
	\tadAxioma{Significados(d)}{\IF $\#$claves(d)$=0$
		THEN $\emptyset$
		ELSE Ag(obtener(dameUno(claves(d)), Significados(borrar(dameUno(claves(d)),d)))
		FI}
	Uso el Significados(dicc(nat, conj(placa))) para mi diccLineal y diccLog aunque deberia hacer uno especifico para el diccLog, pero es trivial y es mas amigable a la vista
	
	~	
	
	\tadOperacion{Union}{conj(conj(plc))}{conj(plc)}{}
	\tadAxioma{Union(c)}{\IF $\#$c$=0$
		THEN $\emptyset$
		ELSE dameUno(c)$\cup$Union(sinUno(c))
		FI}
	
	~
	~
	
	
	\AbsFc{diccS}{d : diccS $/$ \\
		($\forall$ n : nat) n$\in$claves(e.diccLineal) $\Rightarrow_L$ obtener(n, e.diccLineal$=$obtener(n, d))\\
		$\land$ def?(n, e.diccLineal) $=$ Def?(n, d) }
	
	~
	~
	
	
	\tituloModulo{Representacion del Iterador de Diccionaro de Sanciones}
	\begin{Estructura}{itS}[it]
		Donde $it$ es itDicc(nat, conj(placa))
	\end{Estructura}
	
	\Rep[itS][it]{true}
	
	~
	~
	
	
	\AbsFc[itS]{itBi(tupla(nat, conj(placa)))}[i]{crearItBi(Anteriores(it), Siguientes(it))}

\begin{Algoritmos}
	
	\begin{algorithm}[H]
		\caption{iCrearDiccS}
		\begin{algorithmic}[1]
			\Procedure{iCrearDiccS}{\texttt{in} sig : \texttt{conj(placa)}} $\to res$ : estr
			\State $res$.diccLog$\leftarrow$ Vacio($\#$(sig)) //vacio de diccionario logaritmico \Comment $\Ogr$(1)
			\State $res$.diccLineal$\leftarrow$ Vacio() //vacio de diccionario lineal \Comment $\Ogr$(1)
			\State $res$.actualizar $\leftarrow$ false \Comment $\Ogr$(1) 
			\EndProcedure
		\end{algorithmic}
		\underline{Complejidad:} $\Ogr$(1)
	\end{algorithm}
	
	\begin{algorithm}[H]
		\caption{iDefinir}
		\begin{algorithmic}[1]
			\Procedure{iDefinir}{\texttt{in/out} e : \texttt{estr}, \texttt{in} s : \texttt{nat}, \texttt{in} sig : \texttt{conj(placa)}} $\to res$ : itS
			\State it$\leftarrow$ Definir(e.diccLineal, s, sig) //definir de diccLineal \Comment $\Ogr$($\#$sig)
			\State $res \leftarrow$ it \Comment $\Ogr$(1)
			\State $res$.actualizar $\leftarrow$ true \Comment $\Ogr$(1) 
			\EndProcedure
		\end{algorithmic}
		\underline{Complejidad:} $\Ogr$($\#$(sig))
	\end{algorithm}

	\begin{algorithm}[H]
		\caption{iObtener}
		\begin{algorithmic}[1]
			\Procedure{iObtener}{\texttt{in/out} e : \texttt{estr}, \texttt{in} s : \texttt{nat}} $\to res$ : conj(placa)
			\If{e.actualizar} \Comment $\Ogr$(1)
				\State it $\leftarrow$ CrearIt(e) \Comment $\Ogr$(1)
				\While{HaySiguiente(it)} // $\Ogr$(1) cantidad de claves de diccLineal veces \Comment $\Ogr$($\#$claves(e.diccLineal))
					\State e.diccLog $\leftarrow$ Definir(e.diccLog, SiguienteClave(it), SiguienteSignificado(it)) //Definir de diccLog \Comment $\Ogr$(1) 
					\State avanzar(it) \Comment $\Ogr$(1) 
				\EndWhile
				\State e.actualizar $\leftarrow$ false \Comment $\Ogr$(1) 
			\EndIf
			\State Obtener(e.diccLog, s) $\Ogr$(1)
			\EndProcedure
		\end{algorithmic}
		\underline{Complejidad:} $\Ogr$($\#$claves(e.diccLineal))
		\\
		\underline{Justificacion:} $\Ogr$($\#$claves(e.diccLineal))+$\Ogr$(log $\#$claves(e.diccLineal)). En el peor de los casos sera la $\Ogr$($\#$claves(e.diccLineal)) pues $\Ogr$($\#$claves(e.diccLog))$>\Ogr$(log $\#$claves(e.diccLineal)). Y en el peor de los casos $\#$claves(e.diccLog) sera igual a la cantidad de agentes (esto sera cuando todos los agentes tengan diferentes sanciones). Cuando la cantidad de sanciones se mantenga (e.actualizar $=$ false) entonces tendremos una complejidad de $\Ogr$(log $\#$claves(e.diccLineal)) puesto que nunca entraremos en el while.
	\end{algorithm}	
	
	
\end{Algoritmos}
\end{Representacion}