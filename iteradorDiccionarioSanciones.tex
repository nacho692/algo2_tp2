\begin{Interfaz}

	\textbf{se explica con}: \tadNombre{Iterador Bidireccional($\alpha$)}.

	\textbf{usa}: nat, bool, diccS, tupla, conj(placa)

	\textbf{géneros}: \TipoVariable{its}.

	\tituloModulo{Operaciones básicas de iterador de sanciones}
	
		
	\InterfazFuncion{CrearIts}{\In{ds}{diccS}}{itS}
	{SecuSuby($res$)$\igobs$ordenar$\pi1$(secuenciarDic(ds))}
	[$\Ogr$(1)]
	[Crea iterador de sanciones]
	
	\InterfazFuncion{HaySiguiente}{\In{its}{itS}}{bool}
	{$res \igobs$ haySiguiente?(its)}
	[$\Ogr$(1)]
	[True si y solo si hay elementos siguientes]
	
	\InterfazFuncion{Siguiente}{\In{its}{itS}}{tupla(nat, conj(placa))}
	[haySiguiente?(its)]
	{$res \igobs$ siguiente(its)}
	[$\Ogr$(1)]
	[Devuelve el elemento siguiente por referencia]
	[La tupla no es modificable]
	
	\InterfazFuncion{SiguienteClave}{\In{its}{itS}}{nat}
	[haySiguiente?(its)]
	{$res \igobs$ siguiente(its).clave}
	{$\Ogr$(1)}
	{Devuelve la clave del siguiente iterador}
	[La clave no es modificable]
	
	\InterfazFuncion{SiguienteSignificado}{\In{its}{itS}}{conj(placa)}
	[haySiguiente?(its)]
	{alias($res \igobs$ siguiente(its).significado)}
	[$\Ogr$(1)]
	[Devuelve el significado del siguiente]
	[El significado es modificable]
	
	\InterfazFuncion{Avanzar}{\Inout{its}{itS}}{itS}
	[it$=$it$_0$ $\land$ haySiguiente?(its)]
	{it $\igobs$ avanzar(it$_0$)}
	[$\Ogr$(1)]
	[Avanza en uno el iterador]

	\InterfazFuncion{EliminarSiguiente}{\Inout{its}{itS}}{}
	[it$=$it$_0$ $\land$ haySiguiente?(its)]
	{it $\igobs$ eliminarSiguiente(it$_0$)}
	[$\Ogr$(1)]
	[Elimina el elemento que se encuentra en la posicion siguiente]


\end{Interfaz}

\begin{Representacion}
	
	Basicamente es una capa que trabaja sobre un iterador de lista, todas las funciones del iterador de sanciones hacen que el diccionario actualice en la proxima busqueda, ya que permite modificar los valores internos del diccionario.
	
	\tituloModulo{Representacion del Iterador de Diccionaro de Sanciones}
	\begin{Estructura}{itS}[itSanc]
	    \begin{Tupla}[itSanc]
			\tupItem{actualizar}{puntero(bool)}
			\tupItem{itL}{itLista(tupla(nat, conj(placa)))}
		\end{Tupla}
	\end{Estructura}
	
	\Rep[itS][it]{Rep(it.itL)}
	
	
	\AbsFc[itS]{itBi(tupla(nat, conj(placa)))}[i]{Abs(itL)}

\end{Representacion}

\begin{Algoritmos}
	
	\begin{algorithm}[H]
		\caption{iCrearIt}
		\begin{algorithmic}[1]
			\Procedure{iCrearIt}{\texttt{in} e : \texttt{estr}} $\to res$ itLista
			\State $res$.actualizar $\gets$ $\&e$.actualizar \Comment $\Ogr(1)$
			\State $res \leftarrow$ CrearIt($e$.lista) //uso el crearIt de lista \Comment $\Ogr$(1)
			\EndProcedure 
		\end{algorithmic}
		\underline{Complejidad:} $\Ogr$(1)
	\end{algorithm}
	
	\begin{algorithm}[H]
		\caption{iHaySiguiente}
		
		\begin{algorithmic}[1]
			\Procedure{iHaySiguiente}{\texttt{in} it : \texttt{itSanc}} $\to res$ bool
			\State $res \leftarrow$ HaySiguiente($it$.itL) //uso el HaySiguiente de itLista \Comment $\Ogr$(1)
			\EndProcedure 
		\end{algorithmic}
		\underline{Complejidad:} $\Ogr$(1)
	\end{algorithm}
	
	\begin{algorithm}[H]
		\caption{iSiguiente}
		
		\begin{algorithmic}[1]
			\Procedure{iSiguiente}{\texttt{in} it : \texttt{itSanc}} $\to res$ $\langle$nat, conj(placa)$\rangle$
			\State $it$.*actualizar $\gets$ true \Comment $\Ogr(1)$
			\State $res \leftarrow$ Siguiente($it$.itL) //uso el Siguiente de itLista \Comment $\Ogr(1)$
			\EndProcedure 
		\end{algorithmic}
		\underline{Complejidad:} $\Ogr$(1)
	\end{algorithm}
	
	\begin{algorithm}[H]
		\caption{iSiguienteClave}
		
		\begin{algorithmic}[1]
			\Procedure{iSiguienteClave}{\texttt{in} it : \texttt{itSanc}} $\to res$ nat
			\State $res \leftarrow$ Siguiente($it$.itL).clave //uso el Siguiente de itLista \Comment $\Ogr$(1)
			\EndProcedure 
		\end{algorithmic}
		\underline{Complejidad:} $\Ogr$(1)
	\end{algorithm}
	
	\begin{algorithm}[H]
		\caption{iSiguienteSignificado}
		
		\begin{algorithmic}[1]
			\Procedure{iSiguienteSignificado}{\texttt{in} it : \texttt{itSanc}} $\to res$ conj(placa)
			\State $it$.*actualizar $\gets$ true \Comment $\Ogr$(1)
			\State $res \leftarrow$ Siguiente($it$.itL).significado //uso el Siguiente de itLista \Comment $\Ogr$(1)
			\EndProcedure 
		\end{algorithmic}
		\underline{Complejidad:} $\Ogr$(1)
	\end{algorithm}
	
	\begin{algorithm}[H]
		\caption{iAvanzar}
		
		\begin{algorithmic}[1]
			\Procedure{iAvanzar}{\texttt{in/out} it : \texttt{itSanc}}
			\State $it$.*actualizar $\gets$ true \Comment $\Ogr$(1)
			\State Avanzar($it$.itL) //uso el Avanzar de itLista \Comment $\Ogr$(1)
			\EndProcedure 
		\end{algorithmic}
		\underline{Complejidad:} $\Ogr$(1)
	\end{algorithm}
	
	\begin{algorithm}[H]
		\caption{iEliminarSiguiente}
		
		\begin{algorithmic}[1]
			\Procedure{iEliminarSiguiente}{\texttt{in/out} it : \texttt{itSanc}}
			\State $it$.*actualizar $\gets$ true \Comment $\Ogr$(1)			
			\State EliminarSiguiente($it$.itL) //uso el EliminarSiguiente de itLista \Comment $\Ogr$(1)
			\EndProcedure 
		\end{algorithmic}
		\underline{Complejidad:} $\Ogr$(1)
	\end{algorithm}	
	
\end{Algoritmos}