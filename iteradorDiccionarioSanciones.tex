\begin{Interfaz}

	\textbf{se explica con}: \tadNombre{Iterador Bidireccional($\alpha$)}.

	\textbf{usa}: nat, bool, diccS, tupla, conj(placa)

	\textbf{géneros}: \TipoVariable{its}.

	\tituloModulo{Operaciones básicas de iterador de sanciones}
	
	Para simplificar las cosas usaremos clave y significado en vez de $\Pi1$ y $\Pi2$ cuanto utilicemos una tupla(nat, conj(placa))
	
	\InterfazFuncion{CrearIts}{\In{ds}{diccS}}{itS}
	{SecuSuby($res$)$\igobs$ordenar$\pi1$(secuenciarDic(ds))}
	[$\Ogr$(1)]
	[crea iterador de sanciones]
	
	\InterfazFuncion{HaySiguiente}{\In{its}{itS}}{bool}
	{$res \igobs$ haySiguiente?(its)}
	[$\Ogr$(1)]
	[me retorna true si hay quedan elementos para avanzar]
	
	\InterfazFuncion{Siguiente}{\In{its}{itS}}{tupla(nat, conj(placa))}
	[haySiguiente?(its)]
	{alias($res \igobs$ siguiente(its))}
	[$\Ogr$(1)]
	[devuelve el elemento siguiente del iterador]
	
	\InterfazFuncion{SiguienteClave}{\In{its}{itS}}{nat}
	[haySiguiente?(its)]
	{alias($res \igobs$ siguiente(its).clave)}
	{$\Ogr$(1)}
	{devuelve la clave del siguiente iterador}
	
	\InterfazFuncion{SiguienteSignificado}{\In{its}{itS}}{conj(placa)}
	[haySiguiente?(its)]
	{alias($res \igobs$ siguiente(its).significado)}
	[$\Ogr$(1)]
	[devuelve el significado del siguiente iterador]
	
	\InterfazFuncion{Avanzar}{\Inout{its}{itS}}{itS}
	[it$=$it$_0$ $\land$ haySiguiente?(its)]
	{it $\igobs$ avanzar(it$_0$)}
	[$\Ogr$(1)]
	[avanza en uno el iterador]

	\InterfazFuncion{EliminarSiguiente}{\Inout{its}{itS}}{}
	[it$=$it$_0$ $\land$ haySiguiente?(its)]
	{it $\igobs$ eliminarSiguiente(it$_0$)}
	[$\Ogr$(1)]
	[elimina la clave del elemento que se encuentra en la posicion siguiente]


\end{Interfaz}

\begin{Representacion}
	
	
	\tituloModulo{Representacion del Iterador de Diccionaro de Sanciones}
	\begin{Estructura}{itS}[itDic]
		Donde $itDic$ es itDicc(nat, conj(placa))
	\end{Estructura}
	
	\Rep[itS][it]{true}
	
	~
	~
	
	
	\AbsFc[itS]{itBi(tupla(nat, conj(placa)))}[i]{crearItBi(Anteriores(it), Siguientes(it))}

\begin{Algoritmos}
	
	\begin{algorithm}[H]
		\caption{iCrearIt}
		
		\begin{algorithmic}[1]
			\Procedure{iCrearIt}{\texttt{in} e : \texttt{estr}} $\to res$ itDic
			\State $res \leftarrow$ CrearIt(e.diccLineal) //uso el crearIt de diccLineal \Comment $\Ogr$(1)
			\EndProcedure 
		\end{algorithmic}
		\underline{Complejidad:} $\Ogr$(1)
	\end{algorithm}
	
	\begin{algorithm}[H]
		\caption{iHaySiguiente}
		
		\begin{algorithmic}[1]
			\Procedure{iHaySiguiente}{\texttt{in} itd : \texttt{itDic}} $\to res$ bool
			\State $res \leftarrow$ HaySiguiente(itd) //uso el HaySiguiente de itDicc \Comment $\Ogr$(1)
			\EndProcedure 
		\end{algorithmic}
		\underline{Complejidad:} $\Ogr$(1)
	\end{algorithm}
	
	\begin{algorithm}[H]
		\caption{iSiguiente}
		
		\begin{algorithmic}[1]
			\Procedure{iSiguiente}{\texttt{in} itd : \texttt{itDic}} $\to res$ $<$nat, conj(placa)$>$
			\State $res \leftarrow$ Siguiente(itd) //uso el Siguiente de itDicc \Comment $\Ogr$(1)
			\EndProcedure 
		\end{algorithmic}
		\underline{Complejidad:} $\Ogr$(1)
	\end{algorithm}
	
	\begin{algorithm}[H]
		\caption{iSiguienteClave}
		
		\begin{algorithmic}[1]
			\Procedure{iSiguienteClave}{\texttt{in} itd : \texttt{itDic}} $\to res$ nat
			\State $res \leftarrow$ SiguienteClave(itd) //uso el SiguienteClave de itDicc \Comment $\Ogr$(1)
			\EndProcedure 
		\end{algorithmic}
		\underline{Complejidad:} $\Ogr$(1)
	\end{algorithm}
	
	\begin{algorithm}[H]
		\caption{iSiguienteSignificado}
		
		\begin{algorithmic}[1]
			\Procedure{iSiguienteSignificado}{\texttt{in} itd : \texttt{itDic}} $\to res$ conj(placa)
			\State $res \leftarrow$ SiguienteSignificado(itd) //uso el SiguienteSignificado de itDicc \Comment $\Ogr$(1)
			\EndProcedure 
		\end{algorithmic}
		\underline{Complejidad:} $\Ogr$(1)
	\end{algorithm}
	
	\begin{algorithm}[H]
		\caption{iAvanzar}
		
		\begin{algorithmic}[1]
			\Procedure{iAvanzar}{\texttt{in/out} itd : \texttt{itDic}} $\to res$ itDic
			\State $res \leftarrow$ Avanzar(itd) //uso el Avanzar de itDicc \Comment $\Ogr$(1)
			\EndProcedure 
		\end{algorithmic}
		\underline{Complejidad:} $\Ogr$(1)
	\end{algorithm}
	
	\begin{algorithm}[H]
		\caption{iEliminarSiguiente}
		
		\begin{algorithmic}[1]
			\Procedure{iEliminarSiguiente}{\texttt{in/out} itd : \texttt{itDic}, \texttt{in/out} e : \texttt{estr}}
			\State EliminarSiguiente(itd) //uso el EliminarSiguiente de itDicc \Comment $\Ogr$(1)
			\State e.actualizar $\leftarrow$ true \Comment $\Ogr$(1)
			\EndProcedure 
		\end{algorithmic}
		\underline{Complejidad:} $\Ogr$(1)
	\end{algorithm}	
	
\end{Algoritmos}
\end{Representacion}